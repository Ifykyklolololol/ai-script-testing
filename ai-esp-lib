-- box_bw_outline_esp_v2.lua
-- Black & White (grayscale) animated Box ESP with improved corner joining and outline.
-- Fixes "pixel off" gaps via pixel alignment + slight segment overlap + continuous outline rectangle.
-- Requires an executor that supports the Drawing API.

--== CONFIG ==--
getgenv().BWBoxESP = {
    Enabled = true,
    TeamCheck = false,              -- don't draw on teammates
    MaxDistance = 5000,             -- studs
    Thickness = 2,                  -- main line thickness
    SegmentsPerEdge = 24,           -- higher = smoother gradient
    Speed = 0.18,                   -- grayscale travel speed
    Transparency = 1,               -- 0..1 for main line

    -- Outline
    Outline = true,                 -- draw an outline behind the main line
    OutlineThickness = 2,           -- added on top of main Thickness
    OutlineTransparency = 1,        -- 0..1
    OutlineColor = Color3.new(0,0,0),

    OnlyAlive = true,               -- only draw when humanoid health > 0

    -- Anti-gap helpers
    PixelAlign = true,              -- quantize coordinates for crisp joins
    SegmentOverlapPx = 0.75,        -- small overlap per segment to avoid tiny gaps
}

--== IMPLEMENTATION ==--

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local Camera = Workspace.CurrentCamera

local LocalPlayer = Players.LocalPlayer
local cfg = getgenv().BWBoxESP

-- Safety: Drawing API check
if not Drawing or not Drawing.new then
    warn("[BWBoxESP] Drawing API not found. This script requires an executor with Drawing support.")
    return
end

-- Utilities
local function isAlive(hum)
    if not hum then return false end
    return hum.Health > 0
end

local function isSameTeam(a, b)
    if not a or not b then return false end
    local ok, same = pcall(function()
        return a.Team ~= nil and b.Team ~= nil and a.Team == b.Team
    end)
    return ok and same or false
end

-- Align a coordinate to pixel centers to reduce gaps.
-- For odd thickness, align to x.5; for even thickness, align to integer.
local function alignCoord(v, thickness)
    if not cfg.PixelAlign then return v end
    local isOdd = (math.floor(thickness + 0.5) % 2) == 1
    if isOdd then
        return math.floor(v) + 0.5
    else
        return math.floor(v + 0.5)
    end
end

local function newLine(thickness, transparency, z)
    local line = Drawing.new("Line")
    line.Visible = false
    line.Thickness = thickness
    line.Transparency = transparency
    pcall(function() line.ZIndex = z or 2 end)
    return line
end

local function tryNewSquare()
    local ok, obj = pcall(function() return Drawing.new("Square") end)
    if ok and obj then
        obj.Visible = false
        obj.Filled = false
        pcall(function() obj.ZIndex = 1 end)
        return obj
    end
    return nil
end

-- Compute a 2D screen-space bounding rectangle for a character model
local function getScreenRect(model)
    local cf, size = model:GetBoundingBox()
    local half = size * 0.5

    local corners = {
        Vector3.new(-half.X, -half.Y, -half.Z),
        Vector3.new(-half.X, -half.Y,  half.Z),
        Vector3.new(-half.X,  half.Y, -half.Z),
        Vector3.new(-half.X,  half.Y,  half.Z),
        Vector3.new( half.X, -half.Y, -half.Z),
        Vector3.new( half.X, -half.Y,  half.Z),
        Vector3.new( half.X,  half.Y, -half.Z),
        Vector3.new( half.X,  half.Y,  half.Z),
    }

    local minX, minY = math.huge, math.huge
    local maxX, maxY = -math.huge, -math.huge
    local anyOnScreen = false

    for _, offset in ipairs(corners) do
        local world = cf:PointToWorldSpace(offset)
        local v2, onScreen = Camera:WorldToViewportPoint(world)
        if onScreen and v2.Z > 0 then
            anyOnScreen = true
        end
        minX = math.min(minX, v2.X)
        maxX = math.max(maxX, v2.X)
        minY = math.min(minY, v2.Y)
        maxY = math.max(maxY, v2.Y)
    end

    if not anyOnScreen then
        return nil
    end

    local width = math.max(0, maxX - minX)
    local height = math.max(0, maxY - minY)
    if width < 2 or height < 2 then
        return nil
    end

    return minX, minY, width, height
end

-- Build segment endpoints for rectangle perimeter with slight overlap
local function rectSegments(x, y, w, h, perEdge, overlapPx, baseThickness)
    local segs = {}

    local function addEdge(x1, y1, x2, y2)
        local dx, dy = x2 - x1, y2 - y1
        local len = math.sqrt(dx*dx + dy*dy)
        local overFrac = 0
        if overlapPx and overlapPx > 0 and len > 0 then
            overFrac = overlapPx / len
        end
        for i = 0, perEdge - 1 do
            local t0 = i / perEdge - overFrac
            local t1 = (i + 1) / perEdge + overFrac
            -- Don't clamp to let edges slightly overreach corners (helps hide gaps)
            local sx = x1 + dx * t0
            local sy = y1 + dy * t0
            local ex = x1 + dx * t1
            local ey = y1 + dy * t1

            -- Pixel align at assignment
            sx = alignCoord(sx, baseThickness)
            sy = alignCoord(sy, baseThickness)
            ex = alignCoord(ex, baseThickness)
            ey = alignCoord(ey, baseThickness)

            segs[#segs + 1] = {sx, sy, ex, ey}
        end
    end

    -- top, right, bottom, left (clockwise)
    addEdge(x, y, x + w, y)         -- top
    addEdge(x + w, y, x + w, y + h) -- right
    addEdge(x + w, y + h, x, y + h) -- bottom
    addEdge(x, y + h, x, y)         -- left

    return segs
end

-- State
local ESP = {}
-- ESP[player] = {
--   pairs = { [1..N] = {main = DrawingLine} },
--   outlineRect = DrawingSquare?,
--   totalSegments = number
-- }

local function clearPlayerEsp(plr)
    local entry = ESP[plr]
    if not entry then return end
    if entry.pairs then
        for _, p in ipairs(entry.pairs) do
            if p.main then pcall(function() p.main.Visible = false p.main:Remove() end) end
        end
    end
    if entry.outlineRect then
        pcall(function() entry.outlineRect.Visible = false entry.outlineRect:Remove() end)
    end
    ESP[plr] = nil
end

local function ensurePlayerEsp(plr, neededSegments)
    local entry = ESP[plr]
    if entry and entry.totalSegments == neededSegments then
        return entry
    end
    if entry then clearPlayerEsp(plr) end

    local pairsArr = table.create(neededSegments)
    for i = 1, neededSegments do
        local mainObj = newLine(cfg.Thickness, cfg.Transparency, 2)
        pairsArr[i] = { main = mainObj }
    end

    local outlineRect = nil
    if cfg.Outline then
        outlineRect = tryNewSquare()
    end

    entry = { pairs = pairsArr, outlineRect = outlineRect, totalSegments = neededSegments }
    ESP[plr] = entry
    return entry
end

-- Main update loop
local lastCleanup = 0
RunService.RenderStepped:Connect(function(dt)
    if not cfg.Enabled then
        for _, entry in pairs(ESP) do
            for _, p in ipairs(entry.pairs) do
                if p.main then p.main.Visible = false end
            end
            if entry.outlineRect then entry.outlineRect.Visible = false end
        end
        return
    end

    local myChar = LocalPlayer.Character
    local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
    local perEdge = math.max(2, cfg.SegmentsPerEdge)
    local totalSegs = 4 * perEdge
    local phaseOffset = (tick() * cfg.Speed) % 1

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer then
            local char = plr.Character
            local root = char and char:FindFirstChild("HumanoidRootPart")
            local hum = char and char:FindFirstChildOfClass("Humanoid")

            local shouldDraw = char ~= nil and root ~= nil
            if shouldDraw and cfg.TeamCheck and isSameTeam(plr, LocalPlayer) then
                shouldDraw = false
            end
            if shouldDraw and cfg.OnlyAlive and not isAlive(hum) then
                shouldDraw = false
            end
            if shouldDraw and myRoot and (myRoot.Position - root.Position).Magnitude > cfg.MaxDistance then
                shouldDraw = false
            end

            local entry = ensurePlayerEsp(plr, totalSegs)

            if shouldDraw then
                local x, y, w, h = getScreenRect(char)
                if x then
                    -- Outline rectangle (continuous) sits behind the segmented main lines
                    if entry.outlineRect and cfg.Outline then
                        local th = cfg.Thickness + cfg.OutlineThickness
                        local ax = alignCoord(x, th)
                        local ay = alignCoord(y, th)
                        local aw = math.max(0, w) -- Size shouldn't be aligned to avoid zero width
                        local ah = math.max(0, h)
                        entry.outlineRect.Position = Vector2.new(ax, ay)
                        entry.outlineRect.Size = Vector2.new(aw, ah)
                        entry.outlineRect.Thickness = th
                        entry.outlineRect.Transparency = cfg.OutlineTransparency
                        entry.outlineRect.Color = cfg.OutlineColor
                        entry.outlineRect.Visible = true
                    end

                    -- Build segments with overlap + pixel alignment
                    local segs = rectSegments(x, y, w, h, perEdge, cfg.SegmentOverlapPx, cfg.Thickness)

                    for i = 1, totalSegs do
                        local s = segs[i]
                        local ln = entry.pairs[i]

                        -- grayscale value 0..1 that travels around the perimeter
                        local t = (i - 1) / totalSegs
                        local wave = math.sin(2 * math.pi * ((t + phaseOffset) % 1))
                        local v = 0.5 + 0.5 * wave -- 0..1
                        local gray = Color3.fromHSV(0, 0, v)

                        ln.main.Color = gray
                        ln.main.Thickness = cfg.Thickness
                        ln.main.Transparency = cfg.Transparency
                        ln.main.From = Vector2.new(s[1], s[2])
                        ln.main.To   = Vector2.new(s[3], s[4])
                        ln.main.Visible = true
                    end
                else
                    -- off-screen
                    for i = 1, totalSegs do
                        local ln = entry.pairs[i]
                        if ln and ln.main then ln.main.Visible = false end
                    end
                    if entry.outlineRect then entry.outlineRect.Visible = false end
                end
            else
                -- not drawable
                for i = 1, totalSegs do
                    local ln = entry.pairs[i]
                    if ln and ln.main then ln.main.Visible = false end
                end
                if entry.outlineRect then entry.outlineRect.Visible = false end
            end
        end
    end

    -- periodic cleanup
    lastCleanup += dt
    if lastCleanup > 1.5 then
        lastCleanup = 0
        for plr, _ in pairs(ESP) do
            if table.find(Players:GetPlayers(), plr) == nil then
                clearPlayerEsp(plr)
            end
        end
    end
end)

-- Public toggle
getgenv().BWBoxESP_SetEnabled = function(v)
    cfg.Enabled = not not v
    if not cfg.Enabled then
        -- quick hide without destroying
        for _, entry in pairs(ESP) do
            for _, p in ipairs(entry.pairs) do
                if p.main then p.main.Visible = false end
            end
            if entry.outlineRect then entry.outlineRect.Visible = false end
        end
    end
end

print("[BWBoxESP v2] Loaded. Fixes corner gaps with pixel-align + overlap + outline rect.")
print("Tweaks:")
print("getgenv().BWBoxESP.PixelAlign = true")
print("getgenv().BWBoxESP.SegmentOverlapPx = 0.75  -- set 0 to disable")
