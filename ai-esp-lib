-- box_chroma_esp.lua
-- Chroma (rainbow) Box ESP with animated gradient that travels around each box.
-- Built for executors that support the Drawing API.
-- Drop this in your executor or loadstring(readfile("box_chroma_esp.lua"))()

--== CONFIG ==--
getgenv().ChromaBoxESP = {
    Enabled = true,
    TeamCheck = false,          -- don't draw on teammates
    MaxDistance = 5000,         -- studs
    Thickness = 2,              -- line thickness
    SegmentsPerEdge = 24,       -- higher = smoother gradient (total segments = 4x this)
    HueSpeed = 0.15,            -- how fast the colors move around the box
    Transparency = 1,           -- 0..1
    OnlyAlive = true,           -- only draw when humanoid > 0
}

--== IMPLEMENTATION ==--

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local Camera = Workspace.CurrentCamera

local LocalPlayer = Players.LocalPlayer

local cfg = getgenv().ChromaBoxESP
local aliveHumanoidStates = {
    [Enum.HumanoidStateType.Dead] = false,
    [Enum.HumanoidStateType.None] = true, -- default to true unless explicitly Dead
}

local function isAlive(hum)
    if not hum then return false end
    if hum.Health <= 0 then return false end
    return true
end

-- Utility: safely check Drawing API
local function newLine()
    local line = Drawing.new("Line")
    line.Visible = false
    line.Thickness = cfg.Thickness
    line.Transparency = cfg.Transparency
    return line
end

if not Drawing or not Drawing.new then
    warn("[ChromaBoxESP] Drawing API not found. This script requires an executor with Drawing support.")
    return
end

-- Store ESP state per player
local ESP = {}
-- Each entry:
-- ESP[player] = {
--   lines = { [1..TotalSegments] = DrawingLine },
--   totalSegments = number
-- }

local function clearPlayerEsp(plr)
    local entry = ESP[plr]
    if not entry then return end
    if entry.lines then
        for _, ln in ipairs(entry.lines) do
            pcall(function() ln.Visible = false ln:Remove() end)
        end
    end
    ESP[plr] = nil
end

local function ensurePlayerEsp(plr)
    local entry = ESP[plr]
    local needed = math.max(4 * math.max(2, cfg.SegmentsPerEdge), 8)
    if entry and entry.totalSegments == needed then
        return entry
    end
    -- rebuild
    if entry then clearPlayerEsp(plr) end
    local lines = table.create(needed)
    for i = 1, needed do
        lines[i] = newLine()
    end
    entry = { lines = lines, totalSegments = needed }
    ESP[plr] = entry
    return entry
end

-- Compute a 2D screen-space bounding rectangle for a character model
local function getScreenRect(model)
    local cf, size = model:GetBoundingBox()
    local half = size * 0.5

    local corners = {
        Vector3.new(-half.X, -half.Y, -half.Z),
        Vector3.new(-half.X, -half.Y,  half.Z),
        Vector3.new(-half.X,  half.Y, -half.Z),
        Vector3.new(-half.X,  half.Y,  half.Z),
        Vector3.new( half.X, -half.Y, -half.Z),
        Vector3.new( half.X, -half.Y,  half.Z),
        Vector3.new( half.X,  half.Y, -half.Z),
        Vector3.new( half.X,  half.Y,  half.Z),
    }

    local minX, minY = math.huge, math.huge
    local maxX, maxY = -math.huge, -math.huge
    local anyOnScreen = false

    for _, offset in ipairs(corners) do
        local world = cf:PointToWorldSpace(offset)
        local v2, onScreen = Camera:WorldToViewportPoint(world)
        if onScreen and v2.Z > 0 then
            anyOnScreen = true
        end
        minX = math.min(minX, v2.X)
        maxX = math.max(maxX, v2.X)
        minY = math.min(minY, v2.Y)
        maxY = math.max(maxY, v2.Y)
    end

    if not anyOnScreen then
        return nil
    end

    local width = math.max(0, maxX - minX)
    local height = math.max(0, maxY - minY)
    if width < 2 or height < 2 then
        return nil
    end

    return minX, minY, width, height
end

-- Split an edge into N segments, returning pair endpoints for each segment
local function subdivideEdge(x1, y1, x2, y2, n)
    local segments = table.create(n)
    for i = 0, n - 1 do
        local t0 = i / n
        local t1 = (i + 1) / n
        local sx = x1 + (x2 - x1) * t0
        local sy = y1 + (y2 - y1) * t0
        local ex = x1 + (x2 - x1) * t1
        local ey = y1 + (y2 - y1) * t1
        segments[i + 1] = {sx, sy, ex, ey}
    end
    return segments
end

-- Build segment endpoints for the rectangle perimeter (clockwise), top->right->bottom->left
local function rectSegments(x, y, w, h, perEdge)
    local segs = {}

    local top = subdivideEdge(x, y, x + w, y, perEdge)
    local right = subdivideEdge(x + w, y, x + w, y + h, perEdge)
    local bottom = subdivideEdge(x + w, y + h, x, y + h, perEdge)
    local left = subdivideEdge(x, y + h, x, y, perEdge)

    for _, s in ipairs(top) do table.insert(segs, s) end
    for _, s in ipairs(right) do table.insert(segs, s) end
    for _, s in ipairs(bottom) do table.insert(segs, s) end
    for _, s in ipairs(left) do table.insert(segs, s) end

    return segs
end

-- Determine if two players are on the same team (safe fallback if teams not present)
local function isSameTeam(a, b)
    if not a or not b then return false end
    pcall(function()
        if a.Team ~= nil and b.Team ~= nil and a.Team == b.Team then
            return true
        end
    end)
    return false
end

-- Main update loop
local lastCleanup = 0
RunService.RenderStepped:Connect(function(dt)
    if not cfg.Enabled then
        -- hide all
        for plr, entry in pairs(ESP) do
            for _, ln in ipairs(entry.lines) do ln.Visible = false end
        end
        return
    end

    local myChar = LocalPlayer.Character
    local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")

    local hueOffset = (tick() * cfg.HueSpeed) % 1
    local perEdge = math.max(2, cfg.SegmentsPerEdge)

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer then
            local char = plr.Character
            local root = char and char:FindFirstChild("HumanoidRootPart")
            local hum = char and char:FindFirstChildOfClass("Humanoid")

            local shouldDraw = char ~= nil and root ~= nil

            if shouldDraw and cfg.TeamCheck and isSameTeam(plr, LocalPlayer) then
                shouldDraw = false
            end
            if shouldDraw and cfg.OnlyAlive and not isAlive(hum) then
                shouldDraw = false
            end
            if shouldDraw and myRoot and (myRoot.Position - root.Position).Magnitude > cfg.MaxDistance then
                shouldDraw = false
            end

            local entry = ensurePlayerEsp(plr)
            local lines, total = entry.lines, entry.totalSegments

            if shouldDraw then
                local x, y, w, h = getScreenRect(char)
                if x and y and w and h then
                    -- Build or reuse segment endpoints
                    local segs = rectSegments(x, y, w, h, perEdge)
                    local totalSegs = #segs

                    -- If config changed since ensure, rebuild lines count if necessary
                    if totalSegs ~= total then
                        clearPlayerEsp(plr)
                        entry = ensurePlayerEsp(plr)
                        lines = entry.lines
                        total = entry.totalSegments
                    end

                    -- Draw each small segment with a different hue so it "travels" around
                    for i = 1, totalSegs do
                        local s = segs[i]
                        local ln = lines[i]
                        local t = (i - 1) / totalSegs
                        local hue = (t + hueOffset) % 1
                        ln.Color = Color3.fromHSV(hue, 1, 1)
                        ln.Thickness = cfg.Thickness
                        ln.Transparency = cfg.Transparency
                        ln.From = Vector2.new(s[0 + 1], s[1 + 1])
                        ln.To   = Vector2.new(s[2 + 1], s[3 + 1])
                        ln.Visible = true
                    end

                    -- Hide any extra lines (shouldn't happen unless counts changed)
                    for j = totalSegs + 1, #lines do
                        lines[j].Visible = false
                    end
                else
                    -- off-screen
                    for _, ln in ipairs(lines) do ln.Visible = false end
                end
            else
                -- not drawable
                for _, ln in ipairs(lines) do ln.Visible = false end
            end
        end
    end

    -- Clean up for players that left (periodic to avoid heavy work every frame)
    lastCleanup += dt
    if lastCleanup > 1.5 then
        lastCleanup = 0
        for plr, entry in pairs(ESP) do
            if table.find(Players:GetPlayers(), plr) == nil then
                clearPlayerEsp(plr)
            end
        end
    end
end)

-- Clean up on script disable or re-execution
local function onDisable()
    for plr, _ in pairs(ESP) do
        clearPlayerEsp(plr)
    end
end

-- optional public API
getgenv().ChromaBoxESP_SetEnabled = function(v)
    cfg.Enabled = not not v
    if not cfg.Enabled then
        onDisable()
    end
end

print("[ChromaBoxESP] Loaded. Use getgenv().ChromaBoxESP to tweak settings. Example:")
print("getgenv().ChromaBoxESP.SegmentsPerEdge = 32")
print("getgenv().ChromaBoxESP.HueSpeed = 0.25")
