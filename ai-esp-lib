-- box_bw_outline_esp.lua
-- Black & White (grayscale) animated Box ESP with optional outline.
-- Gradient "travels" around each box; main line is grayscale only.
-- Requires an executor that supports the Drawing API.

--== CONFIG ==--
getgenv().BWBoxESP = {
    Enabled = true,
    TeamCheck = false,            -- don't draw on teammates
    MaxDistance = 5000,           -- studs
    Thickness = 2,                -- main line thickness
    SegmentsPerEdge = 24,         -- higher = smoother gradient (total segments = 4x)
    Speed = 0.18,                 -- how fast the grayscale travels around the box
    Transparency = 1,             -- 0..1 for main line

    -- Outline settings
    Outline = true,               -- draw an outline behind the main line
    OutlineThickness = 2,         -- added on top of main Thickness
    OutlineTransparency = 1,      -- 0..1
    OutlineColor = Color3.new(0, 0, 0), -- default black outline
    OnlyAlive = true,             -- only draw when humanoid health > 0
}

--== IMPLEMENTATION ==--

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local Camera = Workspace.CurrentCamera

local LocalPlayer = Players.LocalPlayer
local cfg = getgenv().BWBoxESP

-- Safety: Drawing API check
if not Drawing or not Drawing.new then
    warn("[BWBoxESP] Drawing API not found. This script requires an executor with Drawing support.")
    return
end

-- Utils
local function isAlive(hum)
    if not hum then return false end
    return hum.Health > 0
end

local function isSameTeam(a, b)
    if not a or not b then return false end
    local ok, same = pcall(function()
        return a.Team ~= nil and b.Team ~= nil and a.Team == b.Team
    end)
    return ok and same or false
end

local function newLine(thickness, transparency)
    local line = Drawing.new("Line")
    line.Visible = false
    line.Thickness = thickness
    line.Transparency = transparency
    -- many Drawing APIs support ZIndex; set in case it's available
    pcall(function()
        line.ZIndex = 2
    end)
    return line
end

local function newOutlineLine(outThickness, outTransparency, outColor)
    local line = Drawing.new("Line")
    line.Visible = false
    line.Thickness = outThickness
    line.Transparency = outTransparency
    line.Color = outColor
    pcall(function()
        line.ZIndex = 1
    end)
    return line
end

-- Compute a 2D screen-space bounding rectangle for a character model
local function getScreenRect(model)
    local cf, size = model:GetBoundingBox()
    local half = size * 0.5

    local corners = {
        Vector3.new(-half.X, -half.Y, -half.Z),
        Vector3.new(-half.X, -half.Y,  half.Z),
        Vector3.new(-half.X,  half.Y, -half.Z),
        Vector3.new(-half.X,  half.Y,  half.Z),
        Vector3.new( half.X, -half.Y, -half.Z),
        Vector3.new( half.X, -half.Y,  half.Z),
        Vector3.new( half.X,  half.Y, -half.Z),
        Vector3.new( half.X,  half.Y,  half.Z),
    }

    local minX, minY = math.huge, math.huge
    local maxX, maxY = -math.huge, -math.huge
    local anyOnScreen = false

    for _, offset in ipairs(corners) do
        local world = cf:PointToWorldSpace(offset)
        local v2, onScreen = Camera:WorldToViewportPoint(world)
        if onScreen and v2.Z > 0 then
            anyOnScreen = true
        end
        minX = math.min(minX, v2.X)
        maxX = math.max(maxX, v2.X)
        minY = math.min(minY, v2.Y)
        maxY = math.max(maxY, v2.Y)
    end

    if not anyOnScreen then
        return nil
    end

    local width = math.max(0, maxX - minX)
    local height = math.max(0, maxY - minY)
    if width < 2 or height < 2 then
        return nil
    end

    return minX, minY, width, height
end

-- Subdivide edges into segments for smooth animated gradient
local function subdivideEdge(x1, y1, x2, y2, n)
    local segments = table.create(n)
    for i = 0, n - 1 do
        local t0 = i / n
        local t1 = (i + 1) / n
        local sx = x1 + (x2 - x1) * t0
        local sy = y1 + (y2 - y1) * t0
        local ex = x1 + (x2 - x1) * t1
        local ey = y1 + (y2 - y1) * t1
        segments[i + 1] = {sx, sy, ex, ey}
    end
    return segments
end

local function rectSegments(x, y, w, h, perEdge)
    local segs = {}

    local top = subdivideEdge(x, y, x + w, y, perEdge)
    local right = subdivideEdge(x + w, y, x + w, y + h, perEdge)
    local bottom = subdivideEdge(x + w, y + h, x, y + h, perEdge)
    local left = subdivideEdge(x, y + h, x, y, perEdge)

    for _, s in ipairs(top) do table.insert(segs, s) end
    for _, s in ipairs(right) do table.insert(segs, s) end
    for _, s in ipairs(bottom) do table.insert(segs, s) end
    for _, s in ipairs(left) do table.insert(segs, s) end

    return segs
end

-- State
local ESP = {}
-- ESP[player] = {
--   pairs = { [1..N] = {outline = DrawingLine?, main = DrawingLine} },
--   totalSegments = number
-- }

local function clearPlayerEsp(plr)
    local entry = ESP[plr]
    if not entry then return end
    if entry.pairs then
        for _, p in ipairs(entry.pairs) do
            if p.main then pcall(function() p.main.Visible = false p.main:Remove() end) end
            if p.outline then pcall(function() p.outline.Visible = false p.outline:Remove() end) end
        end
    end
    ESP[plr] = nil
end

local function ensurePlayerEsp(plr, neededSegments)
    local entry = ESP[plr]
    if entry and entry.totalSegments == neededSegments then
        return entry
    end
    if entry then clearPlayerEsp(plr) end

    local pairsArr = table.create(neededSegments)
    for i = 1, neededSegments do
        local outlineObj = nil
        if cfg.Outline then
            outlineObj = newOutlineLine(cfg.Thickness + cfg.OutlineThickness, cfg.OutlineTransparency, cfg.OutlineColor)
        end
        local mainObj = newLine(cfg.Thickness, cfg.Transparency)
        pairsArr[i] = { outline = outlineObj, main = mainObj }
    end

    entry = { pairs = pairsArr, totalSegments = neededSegments }
    ESP[plr] = entry
    return entry
end

-- Main update loop
local lastCleanup = 0
RunService.RenderStepped:Connect(function(dt)
    if not cfg.Enabled then
        for _, entry in pairs(ESP) do
            for _, p in ipairs(entry.pairs) do
                if p.main then p.main.Visible = false end
                if p.outline then p.outline.Visible = false end
            end
        end
        return
    end

    local myChar = LocalPlayer.Character
    local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
    local perEdge = math.max(2, cfg.SegmentsPerEdge)

    -- animated phase for grayscale wave
    local phaseOffset = (tick() * cfg.Speed) % 1

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer then
            local char = plr.Character
            local root = char and char:FindFirstChild("HumanoidRootPart")
            local hum = char and char:FindFirstChildOfClass("Humanoid")

            local shouldDraw = char ~= nil and root ~= nil
            if shouldDraw and cfg.TeamCheck and isSameTeam(plr, LocalPlayer) then
                shouldDraw = false
            end
            if shouldDraw and cfg.OnlyAlive and not isAlive(hum) then
                shouldDraw = false
            end
            if shouldDraw and myRoot and (myRoot.Position - root.Position).Magnitude > cfg.MaxDistance then
                shouldDraw = false
            end

            local x, y, w, h = nil, nil, nil, nil
            if shouldDraw then
                x, y, w, h = getScreenRect(char)
                if not x then
                    shouldDraw = false
                end
            end

            local totalSegs = 4 * perEdge
            local entry = ensurePlayerEsp(plr, totalSegs)
            local pairsArr = entry.pairs

            if shouldDraw then
                local segs = rectSegments(x, y, w, h, perEdge)

                for i = 1, totalSegs do
                    local s = segs[i]
                    local pair = pairsArr[i]

                    -- grayscale value 0..1 that travels around the perimeter
                    local t = (i - 1) / totalSegs
                    local wave = math.sin(2 * math.pi * ((t + phaseOffset) % 1))
                    local v = 0.5 + 0.5 * wave -- 0..1
                    local gray = Color3.fromHSV(0, 0, v)

                    if pair.outline then
                        pair.outline.Thickness = cfg.Thickness + cfg.OutlineThickness
                        pair.outline.Transparency = cfg.OutlineTransparency
                        pair.outline.Color = cfg.OutlineColor
                        pair.outline.From = Vector2.new(s[1], s[2])
                        pair.outline.To   = Vector2.new(s[3], s[4])
                        pair.outline.Visible = true
                    end

                    pair.main.Color = gray
                    pair.main.Thickness = cfg.Thickness
                    pair.main.Transparency = cfg.Transparency
                    pair.main.From = Vector2.new(s[1], s[2])
                    pair.main.To   = Vector2.new(s[3], s[4])
                    pair.main.Visible = true
                end
            else
                for i = 1, totalSegs do
                    local pair = pairsArr[i]
                    if pair.main then pair.main.Visible = false end
                    if pair.outline then pair.outline.Visible = false end
                end
            end
        end
    end

    -- periodic cleanup
    lastCleanup += dt
    if lastCleanup > 1.5 then
        lastCleanup = 0
        for plr, _ in pairs(ESP) do
            if table.find(Players:GetPlayers(), plr) == nil then
                clearPlayerEsp(plr)
            end
        end
    end
end)

-- Public toggle
getgenv().BWBoxESP_SetEnabled = function(v)
    cfg.Enabled = not not v
    if not cfg.Enabled then
        -- quick hide without destroying
        for _, entry in pairs(ESP) do
            for _, p in ipairs(entry.pairs) do
                if p.main then p.main.Visible = false end
                if p.outline then p.outline.Visible = false end
            end
        end
    end
end

print("[BWBoxESP] Loaded. Use getgenv().BWBoxESP to tweak settings.")
print("Examples:")
print("getgenv().BWBoxESP.Speed = 0.3")
print("getgenv().BWBoxESP.OutlineColor = Color3.new(1,1,1) -- white outline")
