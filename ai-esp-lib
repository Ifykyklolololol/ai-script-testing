-- box_bw_outline_esp_v3.lua
-- Box ESP (grayscale animated) + Health Bar (green->red gradient) with grayscale border + Name Tag (grayscale gradient)
-- Requires Drawing API support in your executor.
-- This version keeps the corner-gap fixes from v2 (pixel alignment + segment overlap + continuous outline rect).

--== CONFIG ==--
getgenv().BWBoxESP = {
    Enabled = true,
    TeamCheck = false,
    OnlyAlive = true,
    MaxDistance = 5000,

    -- Box
    Thickness = 2,
    SegmentsPerEdge = 24,
    Speed = 0.18,                -- grayscale travel speed around shapes
    Transparency = 1,

    -- Box outline (continuous "Square" underlay). Helps hide micro gaps.
    Outline = true,
    OutlineThickness = 2,
    OutlineTransparency = 1,
    OutlineColor = Color3.new(0,0,0),

    -- Anti-gap helpers
    PixelAlign = true,           -- align to pixel centers for crisp joins
    SegmentOverlapPx = 0.75,     -- small overlap per segment

    -- Health bar
    HealthBar = {
        Enabled = true,
        Width = 5,              -- pixels
        Offset = 4,             -- pixels from the left side of the box
        Segments = 28,          -- vertical segments (higher = smoother gradient)
        BackgroundTransparency = 0.5, -- background behind the fill
        BackgroundColor = Color3.fromRGB(20,20,20),
        FillTransparency = 1,   -- transparency for the colored fill
        -- Health outline (grayscale gradient around the health bar)
        BWBorder = true,
        BorderSegmentsPerEdge = 12,
        BorderOutlineThickness = 2, -- added on top of box thickness for the bar's outline rect
    },

    -- Name tag
    NameTag = {
        Enabled = true,
        UseDisplayName = true,     -- show DisplayName if available else Username
        IncludeUsername = false,   -- append @username after display name
        OffsetY = 14,              -- vertical distance above the box
        Size = 13,                 -- font size
        Font = 2,                  -- 0 UI, 1 System, 2 Plex, 3 Monospace (executor dependent)
        PerCharGradient = true,    -- grayscale gradient across characters
        CharWidthFactor = 0.58,    -- tweak if spacing looks too tight/wide
        BWGradientSpeed = 0.18,    -- reuse grayscale travel speed for text
        Outline = true,            -- text outline (if supported by executor)
        OutlineColor = Color3.new(0,0,0),
        SingleColor = Color3.fromRGB(255,255,255), -- used if PerCharGradient=false
    },
}

--== IMPLEMENTATION ==--
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local Camera = Workspace.CurrentCamera

local LocalPlayer = Players.LocalPlayer
local cfg = getgenv().BWBoxESP

-- Safety: Drawing API check
if not Drawing or not Drawing.new then
    warn("[BWBoxESP v3] Drawing API not found. This script requires an executor with Drawing support.")
    return
end

-- Utilities
local function clamp(v, a, b) if v < a then return a elseif v > b then return b else return v end end

local function isAlive(hum)
    if not hum then return false end
    return hum.Health > 0
end

local function isSameTeam(a, b)
    if not a or not b then return false end
    local ok, same = pcall(function()
        return a.Team ~= nil and b.Team ~= nil and a.Team == b.Team
    end)
    return ok and same or false
end

-- Align a coordinate to pixel centers to reduce gaps.
-- For odd thickness, align to x.5; for even thickness, align to integer.
local function alignCoord(v, thickness)
    if not cfg.PixelAlign then return v end
    local isOdd = (math.floor(thickness + 0.5) % 2) == 1
    if isOdd then
        return math.floor(v) + 0.5
    else
        return math.floor(v + 0.5)
    end
end

local function newLine(thickness, transparency, z)
    local line = Drawing.new("Line")
    line.Visible = false
    line.Thickness = thickness
    line.Transparency = transparency
    pcall(function() line.ZIndex = z or 2 end)
    return line
end

local function tryNewSquare(z)
    local ok, obj = pcall(function() return Drawing.new("Square") end)
    if ok and obj then
        obj.Visible = false
        obj.Filled = false
        pcall(function() obj.ZIndex = z or 1 end)
        return obj
    end
    return nil
end

local function tryNewText(z)
    local ok, obj = pcall(function() return Drawing.new("Text") end)
    if ok and obj then
        obj.Visible = false
        pcall(function() obj.ZIndex = z or 3 end)
        return obj
    end
    return nil
end

-- Compute a 2D screen-space bounding rectangle for a character model
local function getScreenRect(model)
    local cf, size = model:GetBoundingBox()
    local half = size * 0.5

    local corners = {
        Vector3.new(-half.X, -half.Y, -half.Z),
        Vector3.new(-half.X, -half.Y,  half.Z),
        Vector3.new(-half.X,  half.Y, -half.Z),
        Vector3.new(-half.X,  half.Y,  half.Z),
        Vector3.new( half.X, -half.Y, -half.Z),
        Vector3.new( half.X, -half.Y,  half.Z),
        Vector3.new( half.X,  half.Y, -half.Z),
        Vector3.new( half.X,  half.Y,  half.Z),
    }

    local minX, minY = math.huge, math.huge
    local maxX, maxY = -math.huge, -math.huge
    local anyOnScreen = false

    for _, offset in ipairs(corners) do
        local world = cf:PointToWorldSpace(offset)
        local v2, onScreen = Camera:WorldToViewportPoint(world)
        if onScreen and v2.Z > 0 then
            anyOnScreen = true
        end
        minX = math.min(minX, v2.X)
        maxX = math.max(maxX, v2.X)
        minY = math.min(minY, v2.Y)
        maxY = math.max(maxY, v2.Y)
    end

    if not anyOnScreen then
        return nil
    end

    local width = math.max(0, maxX - minX)
    local height = math.max(0, maxY - minY)
    if width < 2 or height < 2 then
        return nil
    end

    return minX, minY, width, height
end

-- Build segment endpoints for rectangle perimeter with slight overlap
local function rectSegments(x, y, w, h, perEdge, overlapPx, baseThickness)
    local segs = {}

    local function addEdge(x1, y1, x2, y2)
        local dx, dy = x2 - x1, y2 - y1
        local len = math.sqrt(dx*dx + dy*dy)
        local overFrac = 0
        if overlapPx and overlapPx > 0 and len > 0 then
            overFrac = overlapPx / len
        end
        for i = 0, perEdge - 1 do
            local t0 = i / perEdge - overFrac
            local t1 = (i + 1) / perEdge + overFrac
            local sx = x1 + dx * t0
            local sy = y1 + dy * t0
            local ex = x1 + dx * t1
            local ey = y1 + dy * t1

            sx = alignCoord(sx, baseThickness)
            sy = alignCoord(sy, baseThickness)
            ex = alignCoord(ex, baseThickness)
            ey = alignCoord(ey, baseThickness)

            segs[#segs + 1] = {sx, sy, ex, ey}
        end
    end

    addEdge(x, y, x + w, y)         -- top
    addEdge(x + w, y, x + w, y + h) -- right
    addEdge(x + w, y + h, x, y + h) -- bottom
    addEdge(x, y + h, x, y)         -- left

    return segs
end

-- State
local ESP = {}
-- ESP[player] = {
--   boxLines = { [1..N] = DrawingLine },
--   boxOutlineRect = Square?,
--   hbBack = Square?,
--   hbFillSegs = { [1..HealthSegments] = Square },
--   hbBorderLines = { [1..(4*perEdge)] = DrawingLine },
--   hbOutlineRect = Square?,
--   nameChars = { [1..len] = Text } or nameText = Text,
-- }

-- Cleanup helpers
local function clearPlayerEsp(plr)
    local entry = ESP[plr]
    if not entry then return end
    local function safeRemove(obj) pcall(function() obj.Visible = false obj:Remove() end) end

    if entry.boxLines then for _, ln in ipairs(entry.boxLines) do safeRemove(ln) end end
    if entry.boxOutlineRect then safeRemove(entry.boxOutlineRect) end

    if entry.hbBack then safeRemove(entry.hbBack) end
    if entry.hbFillSegs then for _, sq in ipairs(entry.hbFillSegs) do safeRemove(sq) end end
    if entry.hbBorderLines then for _, ln in ipairs(entry.hbBorderLines) do safeRemove(ln) end end
    if entry.hbOutlineRect then safeRemove(entry.hbOutlineRect) end

    if entry.nameChars then for _, tx in ipairs(entry.nameChars) do safeRemove(tx) end end
    if entry.nameText then safeRemove(entry.nameText) end

    ESP[plr] = nil
end

local function ensureBox(plr, totalSegs)
    local entry = ESP[plr] or {}
    if not entry.boxLines or #entry.boxLines ~= totalSegs then
        if entry.boxLines then for _, ln in ipairs(entry.boxLines) do pcall(function() ln:Remove() end) end end
        entry.boxLines = table.create(totalSegs)
        for i = 1, totalSegs do
            entry.boxLines[i] = newLine(cfg.Thickness, cfg.Transparency, 2)
        end
    end
    if cfg.Outline then
        if not entry.boxOutlineRect then
            entry.boxOutlineRect = tryNewSquare(1)
        end
    else
        if entry.boxOutlineRect then pcall(function() entry.boxOutlineRect:Remove() end); entry.boxOutlineRect = nil end
    end
    ESP[plr] = entry
    return entry
end

local function ensureHealthBar(plr, hbSegsCount, hbBorderSegs)
    local entry = ESP[plr] or {}
    if cfg.HealthBar.Enabled then
        if not entry.hbBack then
            entry.hbBack = tryNewSquare(1)
            if entry.hbBack then entry.hbBack.Filled = true end
        end
        if (not entry.hbFillSegs) or #entry.hbFillSegs ~= hbSegsCount then
            if entry.hbFillSegs then for _, sq in ipairs(entry.hbFillSegs) do pcall(function() sq:Remove() end) end end
            entry.hbFillSegs = table.create(hbSegsCount)
            for i = 1, hbSegsCount do
                local sq = tryNewSquare(2)
                if sq then sq.Filled = true end
                entry.hbFillSegs[i] = sq
            end
        end
        if cfg.HealthBar.BWBorder then
            if (not entry.hbBorderLines) or #entry.hbBorderLines ~= hbBorderSegs then
                if entry.hbBorderLines then for _, ln in ipairs(entry.hbBorderLines) do pcall(function() ln:Remove() end) end end
                entry.hbBorderLines = table.create(hbBorderSegs)
                for i = 1, hbBorderSegs do
                    entry.hbBorderLines[i] = newLine(cfg.Thickness, 1, 1)
                end
            end
            if not entry.hbOutlineRect then
                entry.hbOutlineRect = tryNewSquare(1)
            end
        else
            if entry.hbBorderLines then for _, ln in ipairs(entry.hbBorderLines) do pcall(function() ln:Remove() end) end; entry.hbBorderLines = nil end
            if entry.hbOutlineRect then pcall(function() entry.hbOutlineRect:Remove() end); entry.hbOutlineRect = nil end
        end
    else
        if entry.hbBack then pcall(function() entry.hbBack:Remove() end); entry.hbBack = nil end
        if entry.hbFillSegs then for _, sq in ipairs(entry.hbFillSegs) do pcall(function() sq:Remove() end) end; entry.hbFillSegs = nil end
        if entry.hbBorderLines then for _, ln in ipairs(entry.hbBorderLines) do pcall(function() ln:Remove() end) end; entry.hbBorderLines = nil end
        if entry.hbOutlineRect then pcall(function() entry.hbOutlineRect:Remove() end); entry.hbOutlineRect = nil end
    end
    ESP[plr] = entry
    return entry
end

local function ensureNameTag(plr, nameLen)
    local entry = ESP[plr] or {}
    if cfg.NameTag.Enabled then
        if cfg.NameTag.PerCharGradient then
            if (not entry.nameChars) or #entry.nameChars ~= nameLen then
                if entry.nameChars then for _, tx in ipairs(entry.nameChars) do pcall(function() tx:Remove() end) end end
                entry.nameChars = table.create(nameLen)
                for i = 1, nameLen do
                    local tx = tryNewText(3)
                    entry.nameChars[i] = tx
                end
                if entry.nameText then pcall(function() entry.nameText:Remove() end); entry.nameText = nil end
            end
        else
            if not entry.nameText then entry.nameText = tryNewText(3) end
            if entry.nameChars then for _, tx in ipairs(entry.nameChars) do pcall(function() tx:Remove() end) end; entry.nameChars = nil end
        end
    else
        if entry.nameChars then for _, tx in ipairs(entry.nameChars) do pcall(function() tx:Remove() end) end; entry.nameChars = nil end
        if entry.nameText then pcall(function() entry.nameText:Remove() end); entry.nameText = nil end
    end
    ESP[plr] = entry
    return entry
end

-- Color helpers
local function healthColor(t) -- t: 0..1, 0=red, 1=green
    -- Map t (0..1) to HSV hue from 0 (red) to ~0.33 (green)
    local hue = t * (1/3)
    return Color3.fromHSV(hue, 1, 1)
end

-- Main loop
local lastCleanup = 0
RunService.RenderStepped:Connect(function(dt)
    if not cfg.Enabled then
        for _, entry in pairs(ESP) do
            if entry.boxLines then for _, ln in ipairs(entry.boxLines) do ln.Visible = false end end
            if entry.boxOutlineRect then entry.boxOutlineRect.Visible = false end
            if entry.hbBack then entry.hbBack.Visible = false end
            if entry.hbFillSegs then for _, sq in ipairs(entry.hbFillSegs) do if sq then sq.Visible = false end end end
            if entry.hbBorderLines then for _, ln in ipairs(entry.hbBorderLines) do ln.Visible = false end end
            if entry.hbOutlineRect then entry.hbOutlineRect.Visible = false end
            if entry.nameChars then for _, tx in ipairs(entry.nameChars) do if tx then tx.Visible = false end end end
            if entry.nameText then entry.nameText.Visible = false end
        end
        return
    end

    local myChar = LocalPlayer.Character
    local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
    local perEdge = math.max(2, cfg.SegmentsPerEdge)
    local boxSegsCount = 4 * perEdge
    local phaseOffset = (tick() * cfg.Speed) % 1

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer then
            local char = plr.Character
            local root = char and char:FindFirstChild("HumanoidRootPart")
            local hum = char and char:FindFirstChildOfClass("Humanoid")

            local shouldDraw = char ~= nil and root ~= nil
            if shouldDraw and cfg.TeamCheck and isSameTeam(plr, LocalPlayer) then
                shouldDraw = false
            end
            if shouldDraw and cfg.OnlyAlive and not isAlive(hum) then
                shouldDraw = false
            end
            if shouldDraw and myRoot and (myRoot.Position - root.Position).Magnitude > cfg.MaxDistance then
                shouldDraw = false
            end

            local entry = ensureBox(plr, boxSegsCount)

            if shouldDraw then
                local x, y, w, h = getScreenRect(char)
                if x then
                    -- Box outline rectangle (continuous)
                    if entry.boxOutlineRect and cfg.Outline then
                        local th = cfg.Thickness + cfg.OutlineThickness
                        local ax = alignCoord(x, th)
                        local ay = alignCoord(y, th)
                        entry.boxOutlineRect.Position = Vector2.new(ax, ay)
                        entry.boxOutlineRect.Size = Vector2.new(w, h)
                        entry.boxOutlineRect.Thickness = th
                        entry.boxOutlineRect.Transparency = cfg.OutlineTransparency
                        entry.boxOutlineRect.Color = cfg.OutlineColor
                        entry.boxOutlineRect.Visible = true
                    end

                    -- Box segmented grayscale perimeter
                    local segs = rectSegments(x, y, w, h, perEdge, cfg.SegmentOverlapPx, cfg.Thickness)
                    for i = 1, boxSegsCount do
                        local s = segs[i]
                        local ln = entry.boxLines[i]
                        local t = (i - 1) / boxSegsCount
                        local wave = math.sin(2 * math.pi * ((t + phaseOffset) % 1))
                        local v = 0.5 + 0.5 * wave
                        local gray = Color3.fromHSV(0, 0, v)

                        ln.Color = gray
                        ln.Thickness = cfg.Thickness
                        ln.Transparency = cfg.Transparency
                        ln.From = Vector2.new(s[1], s[2])
                        ln.To   = Vector2.new(s[3], s[4])
                        ln.Visible = true
                    end

                    -- HEALTH BAR
                    if cfg.HealthBar.Enabled and hum then
                        local hb = cfg.HealthBar
                        local hbSegs = math.max(6, hb.Segments)
                        local hbBorderSegs = 4 * math.max(4, hb.BorderSegmentsPerEdge)
                        entry = ensureHealthBar(plr, hbSegs, hbBorderSegs)

                        local health = clamp(hum.Health, 0, hum.MaxHealth > 0 and hum.MaxHealth or hum.Health)
                        local maxh = hum.MaxHealth > 0 and hum.MaxHealth or 100
                        local ratio = clamp(health / maxh, 0, 1)

                        local barW = hb.Width
                        local barH = h
                        local barX = x - hb.Offset - barW
                        local barY = y

                        -- Background
                        if entry.hbBack then
                            entry.hbBack.Position = Vector2.new(alignCoord(barX, cfg.Thickness), alignCoord(barY, cfg.Thickness))
                            entry.hbBack.Size = Vector2.new(barW, barH)
                            entry.hbBack.Color = hb.BackgroundColor
                            entry.hbBack.Transparency = hb.BackgroundTransparency
                            entry.hbBack.Visible = true
                        end

                        -- Fill segments (from bottom to top), gradient green->red along full height
                        local filledH = barH * ratio
                        local yFillStart = barY + barH - filledH

                        for i = 1, hbSegs do
                            local sq = entry.hbFillSegs[i]
                            if sq then
                                local segY0 = barY + (barH * (i - 1) / hbSegs)
                                local segY1 = barY + (barH * (i) / hbSegs)

                                -- Intersection with filled area
                                local clipTop = math.max(segY0, yFillStart)
                                local clipBottom = segY1
                                local segHeight = clipBottom - clipTop

                                if segHeight > 0 then
                                    -- gradient factor 1 at top -> 0 at bottom
                                    local midT_fromTop = 1 - (( (i - 0.5) / hbSegs ))
                                    local col = healthColor(midT_fromTop)
                                    sq.Position = Vector2.new(alignCoord(barX, cfg.Thickness), alignCoord(clipTop, cfg.Thickness))
                                    sq.Size = Vector2.new(barW, segHeight)
                                    sq.Color = col
                                    sq.Transparency = hb.FillTransparency
                                    sq.Visible = true
                                else
                                    sq.Visible = false
                                end
                            end
                        end

                        -- Health bar grayscale border (animated like the box)
                        if cfg.HealthBar.BWBorder and entry.hbBorderLines then
                            -- Outline rect underlay for extra coverage
                            if entry.hbOutlineRect then
                                local th = cfg.Thickness + hb.BorderOutlineThickness
                                entry.hbOutlineRect.Position = Vector2.new(alignCoord(barX, th), alignCoord(barY, th))
                                entry.hbOutlineRect.Size = Vector2.new(barW, barH)
                                entry.hbOutlineRect.Thickness = th
                                entry.hbOutlineRect.Transparency = 1
                                entry.hbOutlineRect.Color = Color3.new(0,0,0)
                                entry.hbOutlineRect.Visible = true
                            end

                            local hbSegList = rectSegments(barX, barY, barW, barH, math.max(4, hb.BorderSegmentsPerEdge), cfg.SegmentOverlapPx, cfg.Thickness)
                            local totalHBEdges = #hbSegList
                            for i = 1, totalHBEdges do
                                local s = hbSegList[i]
                                local ln = entry.hbBorderLines[i]
                                if ln then
                                    local t2 = (i - 1) / totalHBEdges
                                    local wave2 = math.sin(2 * math.pi * ((t2 + phaseOffset) % 1))
                                    local v2 = 0.5 + 0.5 * wave2
                                    local gray2 = Color3.fromHSV(0, 0, v2)
                                    ln.Color = gray2
                                    ln.Thickness = cfg.Thickness
                                    ln.Transparency = 1
                                    ln.From = Vector2.new(s[1], s[2])
                                    ln.To   = Vector2.new(s[3], s[4])
                                    ln.Visible = true
                                end
                            end
                            -- hide any extra (unlikely if counts match)
                            for j = totalHBEdges + 1, #entry.hbBorderLines do
                                entry.hbBorderLines[j].Visible = false
                            end
                        end
                    end

                    -- NAME TAG
                    if cfg.NameTag.Enabled then
                        local nt = cfg.NameTag
                        local display = (nt.UseDisplayName and plr.DisplayName) or plr.Name
                        if nt.IncludeUsername and plr.Name ~= display then
                            display = string.format("%s (@%s)", display, plr.Name)
                        end

                        entry = ensureNameTag(plr, #display)

                        local cx = x + w/2
                        local nameY = y - nt.OffsetY

                        if nt.PerCharGradient and entry.nameChars then
                            -- Compute approximate width
                            local charW = nt.Size * nt.CharWidthFactor
                            local totalW = charW * #display
                            local startX = cx - (totalW / 2)

                            local phase = (tick() * (nt.BWGradientSpeed or cfg.Speed)) % 1

                            for i = 1, #display do
                                local ch = string.sub(display, i, i)
                                local tx = entry.nameChars[i]
                                if tx then
                                    tx.Text = ch
                                    tx.Size = nt.Size
                                    tx.Font = nt.Font
                                    tx.Position = Vector2.new(alignCoord(startX + (i - 1) * charW, cfg.Thickness), alignCoord(nameY, cfg.Thickness))
                                    -- grayscale across characters + travel
                                    local t3 = (i - 1) / math.max(1, #display - 1)
                                    local wave3 = math.sin(2 * math.pi * ((t3 + phase) % 1))
                                    local v3 = 0.5 + 0.5 * wave3
                                    tx.Color = Color3.fromHSV(0, 0, v3)
                                    -- outline if supported
                                    pcall(function()
                                        tx.Outline = nt.Outline
                                        tx.OutlineColor = nt.OutlineColor
                                        tx.Center = false
                                    end)
                                    tx.Visible = true
                                end
                            end
                        else
                            -- Single text object
                            local tx = entry.nameText
                            if tx then
                                tx.Text = display
                                tx.Size = nt.Size
                                tx.Font = nt.Font
                                tx.Color = nt.SingleColor
                                pcall(function()
                                    tx.Center = true
                                    tx.Outline = nt.Outline
                                    tx.OutlineColor = nt.OutlineColor
                                end)
                                tx.Position = Vector2.new(alignCoord(cx, cfg.Thickness), alignCoord(nameY, cfg.Thickness))
                                tx.Visible = true
                            end
                        end
                    end
                else
                    -- off-screen: hide everything for this player
                    if entry.boxLines then for _, ln in ipairs(entry.boxLines) do ln.Visible = false end end
                    if entry.boxOutlineRect then entry.boxOutlineRect.Visible = false end
                    if entry.hbBack then entry.hbBack.Visible = false end
                    if entry.hbFillSegs then for _, sq in ipairs(entry.hbFillSegs) do if sq then sq.Visible = false end end end
                    if entry.hbBorderLines then for _, ln in ipairs(entry.hbBorderLines) do ln.Visible = false end end
                    if entry.hbOutlineRect then entry.hbOutlineRect.Visible = false end
                    if entry.nameChars then for _, tx in ipairs(entry.nameChars) do if tx then tx.Visible = false end end end
                    if entry.nameText then entry.nameText.Visible = false end
                end
            else
                -- not drawable
                if entry.boxLines then for _, ln in ipairs(entry.boxLines) do ln.Visible = false end end
                if entry.boxOutlineRect then entry.boxOutlineRect.Visible = false end
                if entry.hbBack then entry.hbBack.Visible = false end
                if entry.hbFillSegs then for _, sq in ipairs(entry.hbFillSegs) do if sq then sq.Visible = false end end end
                if entry.hbBorderLines then for _, ln in ipairs(entry.hbBorderLines) do ln.Visible = false end end
                if entry.hbOutlineRect then entry.hbOutlineRect.Visible = false end
                if entry.nameChars then for _, tx in ipairs(entry.nameChars) do if tx then tx.Visible = false end end end
                if entry.nameText then entry.nameText.Visible = false end
            end
        end
    end

    -- periodic cleanup
    lastCleanup += dt
    if lastCleanup > 1.5 then
        lastCleanup = 0
        for plr, _ in pairs(ESP) do
            if table.find(Players:GetPlayers(), plr) == nil then
                clearPlayerEsp(plr)
            end
        end
    end
end)

-- Public toggle
getgenv().BWBoxESP_SetEnabled = function(v)
    cfg.Enabled = not not v
    if not cfg.Enabled then
        for _, entry in pairs(ESP) do
            if entry.boxLines then for _, ln in ipairs(entry.boxLines) do ln.Visible = false end end
            if entry.boxOutlineRect then entry.boxOutlineRect.Visible = false end
            if entry.hbBack then entry.hbBack.Visible = false end
            if entry.hbFillSegs then for _, sq in ipairs(entry.hbFillSegs) do if sq then sq.Visible = false end end end
            if entry.hbBorderLines then for _, ln in ipairs(entry.hbBorderLines) do ln.Visible = false end end
            if entry.hbOutlineRect then entry.hbOutlineRect.Visible = false end
            if entry.nameChars then for _, tx in ipairs(entry.nameChars) do if tx then tx.Visible = false end end end
            if entry.nameText then entry.nameText.Visible = false end
        end
    end
end

print("[BWBoxESP v3] Loaded: Box (BW gradient), HealthBar (green->red), NameTag (BW gradient).")
print("Tweak via getgenv().BWBoxESP, e.g.:")
print("getgenv().BWBoxESP.HealthBar.Width = 6")
print("getgenv().BWBoxESP.NameTag.PerCharGradient = true")
