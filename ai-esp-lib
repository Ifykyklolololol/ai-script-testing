--!nocheck
-- ESP_Drawing_Outlines.lua
-- Drawing API ESP focused on *crisp outlines* (no neon/glow).
-- Clean bracket boxes, tracer + dot (with ring outline), skeleton, arrows, name/distance, and HP bar.
-- Requires an executor that supports the Drawing API.

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local UIS = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera

local defaultConfig = {
	Enabled = true,
	MaxDistance = 3000,
	VisibleOnly = false,
	DisableOnTeammates = false,
	UseTeamColors = false,

	-- Visual tuning
	BaseThickness = 2,       -- base line thickness
	FadeWithDistance = true, -- reduce alpha with distance

	-- Colors (minimal, high-contrast defaults)
	Accent = Color3.fromRGB(180, 180, 255),
	OutlineColor = Color3.fromRGB(15, 15, 20),
	OutlineWidth = 2,        -- how much thicker the outline is than the main line
	OutlineAlpha = 1.0,      -- 0..1 transparency for outline

	NameColor = Color3.fromRGB(245,245,245),
	InfoColor = Color3.fromRGB(190, 200, 230),

	-- Box
	Box = true,
	CornerLenRatio = 0.18,

	-- Skeleton
	Skeleton = true,
	SkeletonMaxDist = 1500,

	-- Tracer
	Tracer = true,
	TracerFrom = "bottom", -- top | center | bottom
	TracerDot = true,

	-- Plate (text + HP bar)
	Plate = true,
	ShowName = true,
	ShowDistance = true,
	HPBar = true,
	PlateYOffset = 2.6,
	TextSize = 14,

	-- Offscreen arrows
	Arrows = true,
	ArrowSize = 14,
	ArrowRadius = 120,

	-- Optional FOV circle
	ShowFOV = false,
	FOVRadius = 140,
}

-- Utilities
local function hasDrawing()
	return (typeof(Drawing) == "table" or typeof(Drawing) == "userdata") and typeof(Drawing.new) == "function"
end

local function toScreen(pos: Vector3)
	local v, on = Camera:WorldToViewportPoint(pos)
	return Vector2.new(v.X, v.Y), on, v.Z
end

local function isVisible(origin: Vector3, target: Vector3, ignoreList: {Instance})
	local params = RaycastParams.new()
	params.FilterDescendantsInstances = ignoreList
	params.FilterType = Enum.RaycastFilterType.Exclude
	params.IgnoreWater = true
	local r = Workspace:Raycast(origin, (target - origin), params)
	return r == nil
end

local function lerp(a,b,t) return a + (b-a)*t end
local function colorLerp(a: Color3, b: Color3, t: number)
	return Color3.new(lerp(a.R,b.R,t), lerp(a.G,b.G,t), lerp(a.B,b.B,t))
end
local function alphaByDistance(cfg, d)
	if not cfg.FadeWithDistance then return 1 end
	return 1 - math.clamp(d / cfg.MaxDistance, 0, 1) * 0.6
end
local function thickByDistance(cfg, d)
	local t = 1 - math.clamp(d / cfg.MaxDistance, 0, 1)
	return math.clamp(cfg.BaseThickness + t * 1.8, cfg.BaseThickness, cfg.BaseThickness + 2)
end
local function teamColor(p: Player, fallback: Color3): Color3
	if p.Team and p.Team.TeamColor then return p.Team.TeamColor.Color end
	return fallback
end

-- Drawing factories
local function newLine()
	local l = Drawing.new("Line")
	l.Visible = false
	l.Thickness = 1
	l.Color = Color3.new(1,1,1)
	l.Transparency = 1
	return l
end
local function drawLine(line, a: Vector2, b: Vector2, th: number, col: Color3, alpha: number)
	line.From = a
	line.To = b
	line.Thickness = th
	line.Color = col
	line.Transparency = alpha
	line.Visible = true
end

local function newText()
	local t = Drawing.new("Text")
	t.Visible = false
	t.Size = 14
	t.Center = true
	t.Outline = true
	t.OutlineColor = Color3.fromRGB(0,0,0)
	t.Color = Color3.new(1,1,1)
	t.Text = ""
	t.Position = Vector2.new(0,0)
	return t
end

local function newSquare()
	local s = Drawing.new("Square")
	s.Visible = false
	s.Thickness = 1
	s.Filled = true
	s.Color = Color3.new(1,1,1)
	s.Transparency = 1
	return s
end

local function newRectOutline()
	local s = Drawing.new("Square")
	s.Visible = false
	s.Thickness = 1
	s.Filled = false
	s.Color = Color3.fromRGB(0,0,0)
	s.Transparency = 1
	return s
end

local function newCircle()
	local c = Drawing.new("Circle")
	c.Visible = false
	c.Filled = true
	c.NumSides = 24
	c.Radius = 2
	c.Color = Color3.new(1,1,1)
	c.Transparency = 1
	return c
end
local function newRing()
	local c = Drawing.new("Circle")
	c.Visible = false
	c.Filled = false
	c.NumSides = 28
	c.Radius = 3
	c.Thickness = 2
	c.Color = Color3.fromRGB(0,0,0)
	c.Transparency = 1
	return c
end

-- Skeleton maps
local SkelR15 = {
	{"Head","UpperTorso"},
	{"UpperTorso","LowerTorso"},
	{"UpperTorso","LeftUpperArm"},
	{"LeftUpperArm","LeftLowerArm"},
	{"LeftLowerArm","LeftHand"},
	{"UpperTorso","RightUpperArm"},
	{"RightUpperArm","RightLowerArm"},
	{"RightLowerArm","RightHand"},
	{"LowerTorso","LeftUpperLeg"},
	{"LeftUpperLeg","LeftLowerLeg"},
	{"LeftLowerLeg","LeftFoot"},
	{"LowerTorso","RightUpperLeg"},
	{"RightUpperLeg","RightLowerLeg"},
	{"RightLowerLeg","RightFoot"},
}
local SkelR6 = {
	{"Head","Torso"},
	{"Torso","Left Arm"},
	{"Torso","Right Arm"},
	{"Torso","Left Leg"},
	{"Torso","Right Leg"},
}

-- ESP class
local ESP = {}
ESP.__index = ESP

function ESP.new()
	local self = setmetatable({}, ESP)
	self.Config = table.clone(defaultConfig)
	self._caches = {} -- keyed by Player
	self._cons = {}
	self._running = false
	self._fov = nil
	return self
end

local function destroyCache(cache)
	for _,obj in ipairs(cache._objects) do
		pcall(function() obj.Visible = false obj:Remove() end)
	end
end

local function makeCache(self, player: Player, model: Model)
	local root = model:FindFirstChild("HumanoidRootPart")
	local hum = model:FindFirstChildOfClass("Humanoid")

	local cache = {
		player = player, model = model, root = root, hum = hum,
		rigType = hum and hum.RigType or nil,
		_objects = {},

		-- bracket corners
		box = {}, boxOutline = {},

		-- tracer + outline + dot + ring
		tracer = newLine(),
		tracerOutline = newLine(),
		dot = newCircle(),
		dotRing = newRing(),

		-- skeleton
		skel = {}, skelOutline = {},

		-- text
		nameText = newText(),
		distText = newText(),

		-- hp
		hpBack = newSquare(),
		hpFill = newSquare(),
		hpOutline = newRectOutline(),

		-- offscreen arrow (3 lines)
		arr = { newLine(), newLine(), newLine() },
		arrOutline = { newLine(), newLine(), newLine() },
	}

	table.insert(cache._objects, cache.tracer)
	table.insert(cache._objects, cache.tracerOutline)
	table.insert(cache._objects, cache.dot)
	table.insert(cache._objects, cache.dotRing)
	for i=1,8 do
		cache.box[i] = newLine(); table.insert(cache._objects, cache.box[i])
		cache.boxOutline[i] = newLine(); table.insert(cache._objects, cache.boxOutline[i])
	end
	for i=1,16 do
		cache.skel[i] = newLine(); table.insert(cache._objects, cache.skel[i])
		cache.skelOutline[i] = newLine(); table.insert(cache._objects, cache.skelOutline[i])
	end
	table.insert(cache._objects, cache.nameText)
	table.insert(cache._objects, cache.distText)
	table.insert(cache._objects, cache.hpBack)
	table.insert(cache._objects, cache.hpFill)
	table.insert(cache._objects, cache.hpOutline)
	for i=1,3 do
		table.insert(cache._objects, cache.arr[i])
		table.insert(cache._objects, cache.arrOutline[i])
	end

	return cache
end

local function hideCache(cache)
	cache.tracer.Visible = false
	cache.tracerOutline.Visible = false
	cache.dot.Visible = false
	cache.dotRing.Visible = false
	for i=1,8 do cache.box[i].Visible = false cache.boxOutline[i].Visible=false end
	for i=1,16 do cache.skel[i].Visible = false cache.skelOutline[i].Visible=false end
	cache.nameText.Visible = false
	cache.distText.Visible = false
	cache.hpBack.Visible = false
	cache.hpFill.Visible = false
	cache.hpOutline.Visible = false
	for i=1,3 do cache.arr[i].Visible = false cache.arrOutline[i].Visible=false end
end

local function getBox2D(model: Model)
	local cf, size = model:GetBoundingBox()
	local half = size/2
	local pts = {
		(cf * CFrame.new( half.X,  half.Y,  half.Z)).Position,
		(cf * CFrame.new( half.X,  half.Y, -half.Z)).Position,
		(cf * CFrame.new( half.X, -half.Y,  half.Z)).Position,
		(cf * CFrame.new( half.X, -half.Y, -half.Z)).Position,
		(cf * CFrame.new(-half.X,  half.Y,  half.Z)).Position,
		(cf * CFrame.new(-half.X,  half.Y, -half.Z)).Position,
		(cf * CFrame.new(-half.X, -half.Y,  half.Z)).Position,
		(cf * CFrame.new(-half.X, -half.Y, -half.Z)).Position,
	}
	local minV = Vector2.new(math.huge, math.huge)
	local maxV = Vector2.new(-math.huge, -math.huge)
	local any = false
	for _,w in ipairs(pts) do
		local s,on = toScreen(w)
		if on then any = true end
		minV = Vector2.new(math.min(minV.X, s.X), math.min(minV.Y, s.Y))
		maxV = Vector2.new(math.max(maxV.X, s.X), math.max(maxV.Y, s.Y))
	end
	return minV, maxV, any
end

local function offscreenTriangle(pos: Vector2, angleRad: number, size: number)
	local tip = pos + Vector2.new(math.cos(angleRad), math.sin(angleRad)) * size
	local left = pos + Vector2.new(math.cos(angleRad + math.rad(140)), math.sin(angleRad + math.rad(140))) * size * 0.7
	local right = pos + Vector2.new(math.cos(angleRad - math.rad(140)), math.sin(angleRad - math.rad(140))) * size * 0.7
	return left, tip, right
end

local function updateOne(self, player: Player, cache)
	local cfg = self.Config
	local model, hum, root = cache.model, cache.hum, cache.root
	if not model or not model.Parent or not hum or hum.Health <= 0 or not root then
		hideCache(cache); return
	end

	local camPos = Camera.CFrame.Position
	local d = (root.Position - camPos).Magnitude
	if d > cfg.MaxDistance then hideCache(cache) return end
	if cfg.DisableOnTeammates and player.Team and LocalPlayer.Team and player.Team == LocalPlayer.Team then
		hideCache(cache) return
	end

	local vis = true
	if cfg.VisibleOnly then vis = isVisible(camPos, root.Position, {LocalPlayer.Character}) end

	local alpha = alphaByDistance(cfg, d)
	local thick = thickByDistance(cfg, d)
	local accent = cfg.UseTeamColors and teamColor(player, cfg.Accent) or cfg.Accent
	local outlineCol, outlineA = cfg.OutlineColor, math.clamp(cfg.OutlineAlpha * alpha, 0, 1)

	-- Plate (texts + hp bar)
	if cfg.Plate then
		local head = model:FindFirstChild("Head")
		local anchor = head or root
		if anchor then
			local p2d, on = toScreen(anchor.Position + Vector3.new(0, cfg.PlateYOffset, 0))
			if on and vis then
				if cfg.ShowName then
					cache.nameText.Text = player.DisplayName ~= "" and player.DisplayName or player.Name
					cache.nameText.Size = cfg.TextSize
					cache.nameText.Position = p2d + Vector2.new(0, -14)
					cache.nameText.Color = cfg.NameColor
					cache.nameText.Outline = true
					cache.nameText.OutlineColor = outlineCol
					cache.nameText.Transparency = alpha
					cache.nameText.Visible = true
				else cache.nameText.Visible = false end

				if cfg.ShowDistance then
					cache.distText.Text = string.format("[%.1f]", d)
					cache.distText.Size = math.floor(cfg.TextSize * 0.9)
					cache.distText.Position = p2d + Vector2.new(0, 2)
					cache.distText.Color = cfg.InfoColor
					cache.distText.Outline = true
					cache.distText.OutlineColor = outlineCol
					cache.distText.Transparency = alpha
					cache.distText.Visible = true
				else cache.distText.Visible = false end

				if cfg.HPBar then
					local w, h = 72, 5
					local backPos = p2d + Vector2.new(-w/2, 18)
					cache.hpBack.Position = backPos
					cache.hpBack.Size = Vector2.new(w, h)
					cache.hpBack.Filled = true
					cache.hpBack.Color = Color3.fromRGB(35, 40, 55)
					cache.hpBack.Transparency = alpha * 0.9
					cache.hpBack.Visible = true

					local hp = math.max(0, hum.Health) / math.max(1, hum.MaxHealth)
					cache.hpFill.Position = backPos
					cache.hpFill.Size = Vector2.new(w * hp, h)
					cache.hpFill.Filled = true
					cache.hpFill.Color = colorLerp(Color3.fromRGB(255,90,90), Color3.fromRGB(110,255,180), hp)
					cache.hpFill.Transparency = alpha
					cache.hpFill.Visible = true

					cache.hpOutline.Position = backPos
					cache.hpOutline.Size = Vector2.new(w, h)
					cache.hpOutline.Color = outlineCol
					cache.hpOutline.Thickness = 1 + cfg.OutlineWidth * 0.5
					cache.hpOutline.Transparency = outlineA
					cache.hpOutline.Visible = true
				else
					cache.hpBack.Visible = false; cache.hpFill.Visible = false; cache.hpOutline.Visible = false
				end
			else
				cache.nameText.Visible = false; cache.distText.Visible = false
				cache.hpBack.Visible = false; cache.hpFill.Visible = false; cache.hpOutline.Visible = false
			end
		end
	end

	-- Box (brackets with crisp outline)
	if cfg.Box then
		local minV, maxV, onScr = getBox2D(model)
		if onScr and vis then
			local w = maxV.X - minV.X; local h = maxV.Y - minV.Y
			local seg = math.clamp(math.min(w,h) * cfg.CornerLenRatio, 10, 28)
			local cx = {minV.X, maxV.X}; local cy = {minV.Y, maxV.Y}
			local i = 0
			local function L(ax, ay, bx, by)
				i += 1
				-- outline under
				drawLine(cache.boxOutline[i], Vector2.new(ax,ay), Vector2.new(bx,by), thick + cfg.OutlineWidth, outlineCol, outlineA)
				-- main
				drawLine(cache.box[i], Vector2.new(ax,ay), Vector2.new(bx,by), thick, accent, alpha)
			end
			-- TL
			L(cx[1], cy[1], cx[1]+seg, cy[1]); L(cx[1], cy[1], cx[1], cy[1]+seg)
			-- TR
			L(cx[2]-seg, cy[1], cx[2], cy[1]); L(cx[2], cy[1], cx[2], cy[1]+seg)
			-- BL
			L(cx[1], cy[2]-seg, cx[1], cy[2]); L(cx[1], cy[2], cx[1]+seg, cy[2])
			-- BR
			L(cx[2]-seg, cy[2], cx[2], cy[2]); L(cx[2], cy[2]-seg, cx[2], cy[2])
			for j=i+1,8 do cache.box[j].Visible=false; cache.boxOutline[j].Visible=false end
		else
			for j=1,8 do cache.box[j].Visible=false; cache.boxOutline[j].Visible=false end
		end
	else
		for j=1,8 do cache.box[j].Visible=false; cache.boxOutline[j].Visible=false end
	end

	-- Tracer with dot (and crisp outline)
	if cfg.Tracer then
		local p2d, onScr = toScreen(root.Position)
		local oy = (cfg.TracerFrom=="top" and 0.12) or (cfg.TracerFrom=="center" and 0.5) or 0.9
		local origin = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y*oy)
		if onScr and vis then
			-- outline first (under)
			drawLine(cache.tracerOutline, origin, p2d, thick + cfg.OutlineWidth, outlineCol, outlineA)
			-- main line
			drawLine(cache.tracer, origin, p2d, thick, accent, alpha)

			if cfg.TracerDot then
				local r = 3 + thick
				cache.dot.Position = p2d
				cache.dot.Radius = r
				cache.dot.Color = accent
				cache.dot.Transparency = alpha
				cache.dot.Visible = true

				cache.dotRing.Position = p2d
				cache.dotRing.Radius = r + math.max(1, cfg.OutlineWidth*0.5)
				cache.dotRing.Color = outlineCol
				cache.dotRing.Thickness = 1 + cfg.OutlineWidth
				cache.dotRing.Transparency = outlineA
				cache.dotRing.Visible = true
			else
				cache.dot.Visible = false; cache.dotRing.Visible = false
			end
		else
			cache.tracer.Visible = false; cache.tracerOutline.Visible = false
			cache.dot.Visible = false; cache.dotRing.Visible = false
		end
	else
		cache.tracer.Visible = false; cache.tracerOutline.Visible = false
		cache.dot.Visible = false; cache.dotRing.Visible = false
	end

	-- Skeleton (with outline)
	if cfg.Skeleton and d <= cfg.SkeletonMaxDist then
		local map = (cache.rigType == Enum.HumanoidRigType.R15) and SkelR15 or SkelR6
		local idx = 0
		for _, pair in ipairs(map) do
			local a = model:FindFirstChild(pair[1])
			local b = model:FindFirstChild(pair[2])
			if a and b and a:IsA("BasePart") and b:IsA("BasePart") then
				local a2d, aOn = toScreen(a.Position)
				local b2d, bOn = toScreen(b.Position)
				if aOn and bOn and vis then
					idx += 1
					-- outline
					drawLine(cache.skelOutline[idx], a2d, b2d, thick + cfg.OutlineWidth, outlineCol, outlineA)
					-- main
					drawLine(cache.skel[idx], a2d, b2d, thick, accent, alpha)
				end
			end
		end
		for j=idx+1, #cache.skel do cache.skel[j].Visible=false; cache.skelOutline[j].Visible=false end
	else
		for j=1, #cache.skel do cache.skel[j].Visible=false; cache.skelOutline[j].Visible=false end
	end

	-- Offscreen arrows (outlined)
	if cfg.Arrows then
		local p2d, onScr, z = toScreen(root.Position)
		if not onScr and z > 0 and vis then
			local vp = Camera.ViewportSize
			local center = Vector2.new(vp.X/2, vp.Y/2)
			local dir = (p2d - center)
			local ang = math.atan2(dir.Y, dir.X)
			local radius = math.min(center.X, center.Y) - cfg.ArrowRadius
			local pos = center + Vector2.new(math.cos(ang), math.sin(ang)) * radius
			local L, T, R = offscreenTriangle(pos, ang, cfg.ArrowSize)

			-- outlines
			drawLine(cache.arrOutline[1], T, L, thick + cfg.OutlineWidth, outlineCol, outlineA)
			drawLine(cache.arrOutline[2], T, R, thick + cfg.OutlineWidth, outlineCol, outlineA)
			drawLine(cache.arrOutline[3], L, R, math.max(1, thick-1) + cfg.OutlineWidth, outlineCol, outlineA)

			-- mains
			drawLine(cache.arr[1], T, L, thick, accent, alpha)
			drawLine(cache.arr[2], T, R, thick, accent, alpha)
			drawLine(cache.arr[3], L, R, math.max(1, thick-1), accent, alpha*0.9)
		else
			for i=1,3 do cache.arr[i].Visible=false; cache.arrOutline[i].Visible=false end
		end
	else
		for i=1,3 do cache.arr[i].Visible=false; cache.arrOutline[i].Visible=false end
	end
end

function ESP:Init(custom)
	if not hasDrawing() then
		warn("[ESP_Drawing_Outlines] Drawing API not found; nothing will render.")
	end
	if custom then
		for k,v in pairs(custom) do
			if self.Config[k] ~= nil then self.Config[k] = v end
		end
	end

	-- cleanup
	for _,cache in pairs(self._caches) do destroyCache(cache) end
	self._caches = {}

	-- FOV
	if self.Config.ShowFOV then
		if not self._fov then self._fov = newCircle() end
		self._fov.Radius = self.Config.FOVRadius
		self._fov.Color = self.Config.OutlineColor
		self._fov.Transparency = 0.6
		self._fov.Filled = false
		self._fov.Thickness = 1 + self.Config.OutlineWidth
		self._fov.Visible = true
	else
		if self._fov then self._fov.Visible = false end
	end

	-- attach existing
	for _,p in ipairs(Players:GetPlayers()) do
		if p ~= LocalPlayer then
			local char = p.Character or p.CharacterAdded:Wait()
			self._caches[p] = makeCache(self, p, char)
		end
	end

	-- events
	table.insert(self._cons, Players.PlayerAdded:Connect(function(p)
		if p == LocalPlayer then return end
		p.CharacterAdded:Connect(function(char)
			local old = self._caches[p]
			if old then destroyCache(old) end
			self._caches[p] = makeCache(self, p, char)
		end)
	end))
	table.insert(self._cons, Players.PlayerRemoving:Connect(function(p)
		local c = self._caches[p]
		if c then destroyCache(c) end
		self._caches[p] = nil
	end))

	return self
end

function ESP:Start()
	if self._running then return end
	self._running = true
	table.insert(self._cons, RunService.RenderStepped:Connect(function()
		-- FOV update
		if self._fov and self.Config.ShowFOV then
			local m = UIS:GetMouseLocation()
			self._fov.Position = m
			self._fov.Visible = true
		end

		if not self.Config.Enabled then
			for _,cache in pairs(self._caches) do hideCache(cache) end
			return
		end

		for _,player in ipairs(Players:GetPlayers()) do
			if player ~= LocalPlayer then
				local char = player.Character
				if char then
					local cache = self._caches[player]
					if not cache or cache.model ~= char then
						if cache then destroyCache(cache) end
						cache = makeCache(self, player, char)
						self._caches[player] = cache
					end
					updateOne(self, player, cache)
				end
			end
		end
	end))
end

function ESP:Stop()
	self._running = false
	for _,c in ipairs(self._cons) do c:Disconnect() end
	self._cons = {}
	for _,cache in pairs(self._caches) do hideCache(cache) end
	if self._fov then self._fov.Visible = false end
end

function ESP:Destroy()
	self:Stop()
	for _,cache in pairs(self._caches) do destroyCache(cache) end
	self._caches = {}
	if self._fov then pcall(function() self._fov:Remove() end) end
	self._fov = nil
end

return ESP.new()
