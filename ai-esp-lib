--!nocheck
-- BillboardESP_v2.lua
-- Aesthetic ESP using BillboardGui + 2D overlay (corner box, tracers, skeleton, arrows)
-- Focused on clean, modern visuals: neon gradient plate, rounded "bracket" corners,
-- softer glow, distance-aware thickness, and tasteful transparency.
-- Drop as ModuleScript "BillboardESP_v2" and require() from a LocalScript.

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera

--====================
-- Public config
--====================
local defaultConfig = {
	Enabled = true,
	MaxDistance = 3000,
	VisibleOnly = false,
	DisableOnTeammates = false,
	UseTeamColors = false,
	FadeWithDistance = true,

	-- Visual style
	Style = "Nebula", -- "Nebula" (purple->blue) | "Mono"
	AccentColor = Color3.fromRGB(180, 90, 255), -- used in Mono
	Glow = true,
	GlowTransparency = 0.4,
	BaseThickness = 2, -- base thickness for lines

	-- Plate
	PlateEnabled = true,
	PlateYOffset = 2.6,
	PlateScale = 1.0,
	ShowName = true,
	ShowDistance = true,
	ShowHealthbar = true,

	-- Box
	BoxEnabled = true,
	CornerLenRatio = 0.18, -- percent of box size per corner segment
	CornerThickness = 2,

	-- Skeleton
	Skeleton = true,
	SkeletonMaxDist = 1200,

	-- Tracers
	Tracers = true,
	TracerFrom = "bottom", -- "top" | "center" | "bottom"
	TracerDot = true,

	-- Arrows (out of FOV)
	Arrows = true,
	ArrowSize = 16,
	ArrowRadius = 120,
}

--====================
-- Internal
--====================
local function getGuiRoot()
	local pg = LocalPlayer:FindFirstChildOfClass("PlayerGui")
	if pg then return pg end
	if gethui then
		local ui = gethui()
		if ui then return ui end
	end
	return game:GetService("CoreGui")
end

local Overlay = Instance.new("ScreenGui")
Overlay.Name = "BillboardESP_Overlay_v2"
Overlay.ResetOnSpawn = false
Overlay.IgnoreGuiInset = true
Overlay.ZIndexBehavior = Enum.ZIndexBehavior.Global
Overlay.Parent = getGuiRoot()

local function toScreen(pos: Vector3)
	local v, on = Camera:WorldToViewportPoint(pos)
	return Vector2.new(v.X, v.Y), on, v.Z
end

local function isVisible(origin: Vector3, target: Vector3, ignoreList: {Instance})
	local params = RaycastParams.new()
	params.FilterDescendantsInstances = ignoreList
	params.FilterType = Enum.RaycastFilterType.Exclude
	params.IgnoreWater = true
	local result = Workspace:Raycast(origin, (target - origin), params)
	return (result == nil)
end

local function lerp(a, b, t) return a + (b-a)*t end

local function colorLerp(a: Color3, b: Color3, t: number)
	return Color3.new(lerp(a.R, b.R, t), lerp(a.G, b.G, t), lerp(a.B, b.B, t))
end

local function nebulaGradient() -- purple->pink->blue
	return ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(194, 90, 255)),
		ColorSequenceKeypoint.new(0.5, Color3.fromRGB(255, 78, 180)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(95, 160, 255)),
	})
end

local function getAccent(cfg, player: Player)
	if cfg.UseTeamColors and player.Team and player.Team.TeamColor then
		return player.Team.TeamColor.Color
	end
	return cfg.AccentColor
end

-- line factory (2D frame with stroke & soft glow)
local function newLine(parent: Instance, z: number): Frame
	local f = Instance.new("Frame")
	f.BackgroundColor3 = Color3.new(1,1,1)
	f.BorderSizePixel = 0
	f.AnchorPoint = Vector2.new(0.5, 0.5)
	f.Size = UDim2.fromOffset(0,0)
	f.Visible = false
	f.ZIndex = z or 25

	local stroke = Instance.new("UIStroke")
	stroke.Thickness = 4
	stroke.Transparency = 0.5
	stroke.LineJoinMode = Enum.LineJoinMode.Round
	stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	stroke.Parent = f

	local round = Instance.new("UICorner")
	round.CornerRadius = UDim.new(0, 999)
	round.Parent = f

	-- gradient on fill (nice for bigger boxes)
	local grad = Instance.new("UIGradient")
	grad.Rotation = 0
	grad.Enabled = false -- only used for plates/large elements
	grad.Parent = f

	f.Parent = parent
	return f
end

local function setLine(f: Frame, a: Vector2, b: Vector2, thickness: number, color: Color3, glow: boolean)
	local dir = b - a
	local len = dir.Magnitude
	if len < 1 then f.Visible = false return end
	f.Visible = true
	f.Size = UDim2.fromOffset(len, thickness)
	f.Position = UDim2.fromOffset(a.X + dir.X/2, a.Y + dir.Y/2)
	f.Rotation = math.deg(math.atan2(dir.Y, dir.X))
	f.BackgroundColor3 = color

	local s = f:FindFirstChildOfClass("UIStroke")
	if s then
		s.Enabled = glow
		s.Color = color
		s.Thickness = math.max(4, thickness + 2)
		s.Transparency = 0.6
	end
end

local function newDot(parent: Instance, size: number, z: number): Frame
	local d = Instance.new("Frame")
	d.Size = UDim2.fromOffset(size, size)
	d.AnchorPoint = Vector2.new(0.5, 0.5)
	d.BackgroundColor3 = Color3.new(1,1,1)
	d.Visible = false
	d.ZIndex = z or 26
	local c = Instance.new("UICorner"); c.CornerRadius = UDim.new(0, 999); c.Parent = d
	local s = Instance.new("UIStroke"); s.ApplyStrokeMode = Enum.ApplyStrokeMode.Border; s.LineJoinMode = Enum.LineJoinMode.Round; s.Thickness = 6; s.Transparency = 0.6; s.Parent = d
	d.Parent = parent
	return d
end

local function setDot(dot: Frame, pos: Vector2, size: number, color: Color3, glow: boolean, alpha: number)
	dot.Position = UDim2.fromOffset(pos.X, pos.Y)
	dot.Size = UDim2.fromOffset(size, size)
	dot.BackgroundColor3 = color
	local s = dot:FindFirstChildOfClass("UIStroke")
	if s then s.Color = color; s.Enabled = glow end
	dot.BackgroundTransparency = 1 - alpha
	dot.Visible = true
end

-- box corner segments
local function ensureCorners(parent: Instance): {Frame}
	local list = {}
	for i=1,8 do table.insert(list, newLine(parent, 22)) end
	return list
end

-- Out-of-FOV arrow (three mini lines shaped like a chevron)
local function ensureArrow(parent: Instance): Frame
	local container = Instance.new("Frame")
	container.Name = "Arrow"
	container.Size = UDim2.fromOffset(20,20)
	container.AnchorPoint = Vector2.new(0.5,0.5)
	container.BackgroundTransparency = 1
	container.Visible = false
	container.ZIndex = 30
	container.Parent = parent

	for i=1,3 do
		local seg = newLine(container, 31)
		seg.Visible = true
	end
	return container
end

local function placeChevron(container: Frame, center: Vector2, size: number, rotDeg: number, color: Color3, glow: boolean)
	container.Position = UDim2.fromOffset(center.X, center.Y)
	container.Rotation = rotDeg
	container.Visible = true

	local children = container:GetChildren()
	local a = children[1] :: Frame
	local b = children[2] :: Frame
	local c = children[3] :: Frame
	if a and b and c then
		setLine(a, Vector2.new(-size*0.4, 0), Vector2.new(0, size*0.6), 2, color, glow)
		setLine(b, Vector2.new(0, size*0.6), Vector2.new(size*0.4, 0), 2, color, glow)
		setLine(c, Vector2.new(-size*0.25, 0), Vector2.new(size*0.25, 0), 2, color, glow)
	end
end

-- Build billboard plate (capsule with gradient + glow)
local function createPlate(adornPart: BasePart, cfg)
	local bb = Instance.new("BillboardGui")
	bb.Adornee = adornPart
	bb.AlwaysOnTop = true
	bb.Size = UDim2.fromOffset(220 * cfg.PlateScale, 66 * cfg.PlateScale)
	bb.StudsOffset = Vector3.new(0, cfg.PlateYOffset, 0)
	bb.Name = "ESPPlate_v2"

	local base = Instance.new("Frame")
	base.Size = UDim2.fromScale(1,1)
	base.BackgroundColor3 = Color3.fromRGB(18, 16, 28)
	base.BackgroundTransparency = 0.15
	base.BorderSizePixel = 0
	base.Parent = bb

	local pill = Instance.new("UICorner")
	pill.CornerRadius = UDim.new(0, 16)
	pill.Parent = base

	local stroke = Instance.new("UIStroke")
	stroke.Thickness = 2
	stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	stroke.Transparency = 0.15
	stroke.Color = Color3.fromRGB(200, 120, 255)
	stroke.Parent = base

	local glow = Instance.new("UIStroke")
	glow.Name = "Glow"
	glow.Thickness = 8
	glow.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	glow.Transparency = cfg.GlowTransparency
	glow.Color = Color3.fromRGB(200, 120, 255)
	glow.Parent = base

	local grad = Instance.new("UIGradient")
	grad.Rotation = 0
	grad.Color = nebulaGradient()
	grad.Enabled = (cfg.Style == "Nebula")
	grad.Parent = base

	local layout = Instance.new("UIListLayout")
	layout.FillDirection = Enum.FillDirection.Vertical
	layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	layout.VerticalAlignment = Enum.VerticalAlignment.Center
	layout.SortOrder = Enum.SortOrder.LayoutOrder
	layout.Parent = base

	local nameLbl, distLbl
	if cfg.ShowName then
		nameLbl = Instance.new("TextLabel")
		nameLbl.Size = UDim2.fromScale(1, 0.6)
		nameLbl.BackgroundTransparency = 1
		nameLbl.TextScaled = true
		nameLbl.Font = Enum.Font.GothamBold
		nameLbl.TextColor3 = Color3.new(1,1,1)
		nameLbl.Text = ""
		nameLbl.LayoutOrder = 1
		nameLbl.Parent = base
	end

	if cfg.ShowDistance then
		distLbl = Instance.new("TextLabel")
		distLbl.Size = UDim2.fromScale(1, 0.35)
		distLbl.BackgroundTransparency = 1
		distLbl.TextScaled = true
		distLbl.Font = Enum.Font.GothamSemibold
		distLbl.TextColor3 = Color3.fromRGB(180, 190, 255)
		distLbl.Text = ""
		distLbl.LayoutOrder = 2
		distLbl.Parent = base
	end

	local hbBack, hbFill
	if cfg.ShowHealthbar then
		hbBack = Instance.new("Frame")
		hbBack.Size = UDim2.fromScale(0.9, 0.12)
		hbBack.BackgroundColor3 = Color3.fromRGB(35, 40, 65)
		hbBack.BorderSizePixel = 0
		hbBack.LayoutOrder = 3
		hbBack.Parent = base

		local corner = Instance.new("UICorner")
		corner.CornerRadius = UDim.new(0, 10)
		corner.Parent = hbBack

		hbFill = Instance.new("Frame")
		hbFill.AnchorPoint = Vector2.new(0, 0.5)
		hbFill.Position = UDim2.fromScale(0, 0.5)
		hbFill.Size = UDim2.fromScale(1, 1)
		hbFill.BackgroundColor3 = Color3.fromRGB(110, 255, 180)
		hbFill.BorderSizePixel = 0
		hbFill.Parent = hbBack

		local corner2 = Instance.new("UICorner")
		corner2.CornerRadius = UDim.new(0, 10)
		corner2.Parent = hbFill

		local g = Instance.new("UIGradient")
		g.Color = ColorSequence.new(Color3.fromRGB(255,90,90), Color3.fromRGB(110,255,180))
		g.Rotation = 0
		g.Parent = hbFill
	end

	return bb, base, nameLbl, distLbl, hbFill, hbBack
end

-- skeleton maps
local skeletonR15 = {
	{"Head","UpperTorso"},
	{"UpperTorso","LowerTorso"},
	{"UpperTorso","LeftUpperArm"},
	{"LeftUpperArm","LeftLowerArm"},
	{"LeftLowerArm","LeftHand"},
	{"UpperTorso","RightUpperArm"},
	{"RightUpperArm","RightLowerArm"},
	{"RightLowerArm","RightHand"},
	{"LowerTorso","LeftUpperLeg"},
	{"LeftUpperLeg","LeftLowerLeg"},
	{"LeftLowerLeg","LeftFoot"},
	{"LowerTorso","RightUpperLeg"},
	{"RightUpperLeg","RightLowerLeg"},
	{"RightLowerLeg","RightFoot"},
}
local skeletonR6 = {
	{"Head","Torso"},
	{"Torso","Left Arm"},
	{"Torso","Right Arm"},
	{"Torso","Left Leg"},
	{"Torso","Right Leg"},
}

local ESP = {}
ESP.__index = ESP

function ESP.new()
	local self = setmetatable({}, ESP)
	self.Config = table.clone(defaultConfig)
	self._caches = {} -- keyed by Player
	self._cons = {}
	self._running = false
	return self
end

local function makeCache(self, player: Player, model: Model)
	local hum: Humanoid? = model:FindFirstChildOfClass("Humanoid")
	local root: BasePart? = model:FindFirstChild("HumanoidRootPart")

	local bb, base, nameLbl, distLbl, hbFill, hbBack = nil, nil, nil, nil, nil, nil
	if root then
		bb, base, nameLbl, distLbl, hbFill, hbBack = createPlate(root, self.Config)
		bb.Parent = model
	end

	local boxHolder = Instance.new("Frame")
	boxHolder.BackgroundTransparency = 1
	boxHolder.Size = UDim2.fromOffset(0,0)
	boxHolder.Parent = Overlay

	local corners = ensureCorners(boxHolder)
	local tracer = newLine(Overlay, 24)
	local tracerDot = newDot(Overlay, 6, 26)

	local sk = {}
	for i=1, 16 do
		table.insert(sk, newLine(Overlay, 23))
	end

	local arrow = ensureArrow(Overlay)

	local cache = {
		player = player,
		model = model,
		hum = hum,
		root = root,
		rigType = hum and hum.RigType or nil,
		billboard = bb,
		base = base,
		nameLbl = nameLbl,
		distLbl = distLbl,
		hbFill = hbFill,
		hbBack = hbBack,
		boxHolder = boxHolder,
		corners = corners,
		tracer = tracer,
		tracerDot = tracerDot,
		skeletonLines = sk,
		arrow = arrow,
	}
	self._caches[player] = cache
	return cache
end

local function destroyCache(cache)
	if cache.billboard then cache.billboard:Destroy() end
	if cache.boxHolder then cache.boxHolder:Destroy() end
	if cache.tracer then cache.tracer:Destroy() end
	if cache.tracerDot then cache.tracerDot:Destroy() end
	if cache.arrow then cache.arrow:Destroy() end
	for _,l in ipairs(cache.skeletonLines) do l:Destroy() end
end

local function getBox2D(model: Model)
	local cf, size = model:GetBoundingBox()
	local half = size/2
	local corners = {
		(cf * CFrame.new( half.X,  half.Y,  half.Z)).Position,
		(cf * CFrame.new( half.X,  half.Y, -half.Z)).Position,
		(cf * CFrame.new( half.X, -half.Y,  half.Z)).Position,
		(cf * CFrame.new( half.X, -half.Y, -half.Z)).Position,
		(cf * CFrame.new(-half.X,  half.Y,  half.Z)).Position,
		(cf * CFrame.new(-half.X,  half.Y, -half.Z)).Position,
		(cf * CFrame.new(-half.X, -half.Y,  half.Z)).Position,
		(cf * CFrame.new(-half.X, -half.Y, -half.Z)).Position,
	}
	local minV = Vector2.new(math.huge, math.huge)
	local maxV = Vector2.new(-math.huge, -math.huge)
	local on = false
	for _, w in ipairs(corners) do
		local s, ok = toScreen(w)
		if ok then on = true end
		minV = Vector2.new(math.min(minV.X, s.X), math.min(minV.Y, s.Y))
		maxV = Vector2.new(math.max(maxV.X, s.X), math.max(maxV.Y, s.Y))
	end
	return minV, maxV, on
end

local function alphaByDistance(cfg, d)
	if not cfg.FadeWithDistance then return 1 end
	local t = math.clamp(d / cfg.MaxDistance, 0, 1)
	return 1 - (t * 0.75)
end

local function thicknessByDistance(cfg, d)
	local base = cfg.BaseThickness
	-- closer = thicker, far = thinner
	local t = 1 - math.clamp(d / cfg.MaxDistance, 0, 1)
	return math.clamp(base + t * 2, base, base + 2)
end

local function updateOne(self, player: Player, cache, dt)
	local cfg = self.Config
	local model = cache.model
	local hum = cache.hum
	local root = cache.root

	if not model or not model.Parent or not hum or hum.Health <= 0 or not root then
		if cache.billboard then cache.billboard.Enabled = false end
		for _,f in ipairs(cache.corners) do f.Visible = false end
		for _,l in ipairs(cache.skeletonLines) do l.Visible = false end
		if cache.tracer then cache.tracer.Visible = false end
		if cache.tracerDot then cache.tracerDot.Visible = false end
		if cache.arrow then cache.arrow.Visible = false end
		return
	end

	local camPos = Camera.CFrame.Position
	local d = (root.Position - camPos).Magnitude
	if d > cfg.MaxDistance then
		if cache.billboard then cache.billboard.Enabled = false end
		for _,f in ipairs(cache.corners) do f.Visible = false end
		for _,l in ipairs(cache.skeletonLines) do l.Visible = false end
		if cache.tracer then cache.tracer.Visible = false end
		if cache.tracerDot then cache.tracerDot.Visible = false end
		if cache.arrow then cache.arrow.Visible = false end
		return
	end

	if cfg.DisableOnTeammates and player.Team and LocalPlayer.Team and player.Team == LocalPlayer.Team then
		if cache.billboard then cache.billboard.Enabled = false end
		for _,f in ipairs(cache.corners) do f.Visible = false end
		for _,l in ipairs(cache.skeletonLines) do l.Visible = false end
		if cache.tracer then cache.tracer.Visible = false end
		if cache.tracerDot then cache.tracerDot.Visible = false end
		if cache.arrow then cache.arrow.Visible = false end
	return end

	local onVis = true
	if cfg.VisibleOnly then
		onVis = isVisible(camPos, root.Position, {LocalPlayer.Character})
	end

	local alpha = alphaByDistance(cfg, d)
	local color = getAccent(cfg, player)
	local faint = colorLerp(color, Color3.new(1,1,1), 0.35)
	local lineThickness = thicknessByDistance(cfg, d)

	--================ Plate =================
	if cache.billboard and cfg.PlateEnabled then
		cache.billboard.Enabled = onVis
		if cache.nameLbl and cfg.ShowName then
			cache.nameLbl.Text = player.DisplayName ~= "" and player.DisplayName or player.Name
			cache.nameLbl.TextTransparency = 1 - alpha
		end
		if cache.distLbl and cfg.ShowDistance then
			cache.distLbl.Text = string.format("⟦ %.1f studs ⟧", d)
			cache.distLbl.TextTransparency = 1 - alpha
		end
		if cache.base then
			local s = cache.base:FindFirstChildOfClass("UIStroke")
			if s then s.Color = (cfg.Style == "Mono") and color or Color3.new(1,1,1); s.Transparency = 0.2 + (1-alpha)*0.6 end
			local g = cache.base:FindFirstChildOfClass("UIGradient")
			if g then g.Enabled = (cfg.Style == "Nebula") end
			local glow = cache.base:FindFirstChild("Glow")
			if glow and glow:IsA("UIStroke") then
				glow.Enabled = cfg.Glow
				glow.Transparency = cfg.GlowTransparency + (1-alpha)*0.2
				glow.Color = (cfg.Style == "Mono") and color or Color3.fromRGB(200,120,255)
			end
		end
		if cache.hbFill and cfg.ShowHealthbar then
			local hp = math.max(0, hum.Health) / math.max(1, hum.MaxHealth)
			cache.hbFill.Size = UDim2.fromScale(hp, 1)
			cache.hbFill.BackgroundTransparency = 1 - alpha
		end
	else
		if cache.billboard then cache.billboard.Enabled = false end
	end

	--================ Box ==================
	if cfg.BoxEnabled then
		local minV, maxV, onScr = getBox2D(model)
		if onScr and onVis then
			local w = maxV.X - minV.X
			local h = maxV.Y - minV.Y
			local seg = math.clamp(math.min(w,h) * cfg.CornerLenRatio, 10, 26)
			local th = math.max(cfg.CornerThickness, lineThickness)

			local cx = {minV.X, maxV.X}
			local cy = {minV.Y, maxV.Y}
			local c = cache.corners

			-- top-left (horiz, vert)
			setLine(c[1], Vector2.new(cx[1], cy[1]), Vector2.new(cx[1]+seg, cy[1]), th, faint, cfg.Glow)
			setLine(c[2], Vector2.new(cx[1], cy[1]), Vector2.new(cx[1], cy[1]+seg), th, faint, cfg.Glow)
			-- top-right
			setLine(c[3], Vector2.new(cx[2]-seg, cy[1]), Vector2.new(cx[2], cy[1]), th, faint, cfg.Glow)
			setLine(c[4], Vector2.new(cx[2], cy[1]), Vector2.new(cx[2], cy[1]+seg), th, faint, cfg.Glow)
			-- bottom-left
			setLine(c[5], Vector2.new(cx[1], cy[2]-seg), Vector2.new(cx[1], cy[2]), th, faint, cfg.Glow)
			setLine(c[6], Vector2.new(cx[1], cy[2]), Vector2.new(cx[1]+seg, cy[2]), th, faint, cfg.Glow)
			-- bottom-right
			setLine(c[7], Vector2.new(cx[2]-seg, cy[2]), Vector2.new(cx[2], cy[2]), th, faint, cfg.Glow)
			setLine(c[8], Vector2.new(cx[2], cy[2]-seg), Vector2.new(cx[2], cy[2]), th, faint, cfg.Glow)

			for _,f in ipairs(c) do f.BackgroundTransparency = 1 - alpha end
		else
			for _,f in ipairs(cache.corners) do f.Visible = false end
		end
	else
		for _,f in ipairs(cache.corners) do f.Visible = false end
	end

	--================ Tracer ================
	if cfg.Tracers then
		local p2d, onScr = toScreen(root.Position)
		local originY = (cfg.TracerFrom == "top" and 0.12) or (cfg.TracerFrom == "center" and 0.5) or 0.9
		local origin = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y*originY)

		if onScr and onVis then
			setLine(cache.tracer, origin, p2d, math.max(1, lineThickness-0), faint, cfg.Glow)
			if cfg.TracerDot then
				setDot(cache.tracerDot, p2d, 6 + lineThickness, color, cfg.Glow, alpha)
			end
			cache.tracer.Transparency = 1 - alpha
		else
			cache.tracer.Visible = false
			cache.tracerDot.Visible = false
		end
	else
		cache.tracer.Visible = false
		cache.tracerDot.Visible = false
	end

	--================ Skeleton ==============
	if cfg.Skeleton and d <= cfg.SkeletonMaxDist then
		local map = (cache.rigType == Enum.HumanoidRigType.R15) and skeletonR15 or skeletonR6
		local idx = 1
		for _, pair in ipairs(map) do
			local a = model:FindFirstChild(pair[1])
			local b = model:FindFirstChild(pair[2])
			if a and b and a:IsA("BasePart") and b:IsA("BasePart") then
				local a2d, aOn = toScreen(a.Position)
				local b2d, bOn = toScreen(b.Position)
				if aOn and bOn and onVis then
					local l = cache.skeletonLines[idx]
					if not l then l = newLine(Overlay, 23); cache.skeletonLines[idx] = l end
					setLine(l, a2d, b2d, math.max(1, lineThickness-0), color, cfg.Glow)
					l.Transparency = 1 - alpha
					idx += 1
				end
			end
		end
		for j = idx, #cache.skeletonLines do
			local L = cache.skeletonLines[j]; if L then L.Visible = false end
		end
	else
		for _,l in ipairs(cache.skeletonLines) do l.Visible = false end
	end

	--================ Arrows =================
	if cfg.Arrows then
		local p2d, onScr, z = toScreen(root.Position)
		local arr = cache.arrow
		if not onScr and z > 0 and onVis then
			local vp = Camera.ViewportSize
			local center = Vector2.new(vp.X/2, vp.Y/2)
			local dir = (p2d - center)
			local ang = math.atan2(dir.Y, dir.X)
			local radius = math.min(center.X, center.Y) - cfg.ArrowRadius
			local pos = center + Vector2.new(math.cos(ang), math.sin(ang)) * radius
			placeChevron(arr, pos, cfg.ArrowSize, math.deg(ang), faint, cfg.Glow)
		else
			arr.Visible = false
		end
	else
		cache.arrow.Visible = false
	end
end

function ESP:Init(custom)
	if custom then
		for k,v in pairs(custom) do
			if self.Config[k] ~= nil then self.Config[k] = v end
		end
	end

	-- cleanup old
	for _,cache in pairs(self._caches) do destroyCache(cache) end
	self._caches = {}

	-- attach to existing players
	for _, p in ipairs(Players:GetPlayers()) do
		if p ~= LocalPlayer then
			local char = p.Character or p.CharacterAdded:Wait()
			self._caches[p] = makeCache(self, p, char)
		end
	end

	-- events
	table.insert(self._cons, Players.PlayerAdded:Connect(function(p)
		if p == LocalPlayer then return end
		p.CharacterAdded:Connect(function(char)
			-- if existing cache, replace
			local old = self._caches[p]
			if old then destroyCache(old) end
			self._caches[p] = makeCache(self, p, char)
		end)
	end))

	table.insert(self._cons, Players.PlayerRemoving:Connect(function(p)
		local c = self._caches[p]
		if c then destroyCache(c) end
		self._caches[p] = nil
	end))

	return self
end

function ESP:Start()
	if self._running then return end
	self._running = true
	table.insert(self._cons, RunService.RenderStepped:Connect(function(dt)
		if not self.Config.Enabled then
			for _,cache in pairs(self._caches) do
				if cache.billboard then cache.billboard.Enabled = false end
				for _,f in ipairs(cache.corners) do f.Visible = false end
				for _,l in ipairs(cache.skeletonLines) do l.Visible = false end
				if cache.tracer then cache.tracer.Visible = false end
				if cache.tracerDot then cache.tracerDot.Visible = false end
				if cache.arrow then cache.arrow.Visible = false end
			end
			return
		end

		if not Overlay.Parent then Overlay.Parent = getGuiRoot() end

		for _, player in ipairs(Players:GetPlayers()) do
			if player ~= LocalPlayer then
				local char = player.Character
				if char then
					local cache = self._caches[player]
					if not cache or cache.model ~= char then
						if cache then destroyCache(cache) end
						cache = makeCache(self, player, char)
						self._caches[player] = cache
					end
					updateOne(self, player, cache, dt)
				end
			end
		end
	end))
end

function ESP:Stop()
	self._running = false
	for _,c in ipairs(self._cons) do c:Disconnect() end
	self._cons = {}
	for _,cache in pairs(self._caches) do
		if cache.billboard then cache.billboard.Enabled = false end
		for _,f in ipairs(cache.corners) do f.Visible = false end
		for _,l in ipairs(cache.skeletonLines) do l.Visible = false end
		if cache.tracer then cache.tracer.Visible = false end
		if cache.tracerDot then cache.tracerDot.Visible = false end
		if cache.arrow then cache.arrow.Visible = false end
	end
end

function ESP:Destroy()
	self:Stop()
	for _,cache in pairs(self._caches) do destroyCache(cache) end
	self._caches = {}
	if Overlay then Overlay:Destroy() end
end

return ESP.new()
